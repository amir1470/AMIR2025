//+------------------------------------------------------------------+
//| SBS TRADING DIAMOND Ver 12.0.mq5                          |
//| Version 12.0 (Scalping, fermeture, panel avancé, logs, trailing) |
//| Par bsamir14, 2025                                              |
//+------------------------------------------------------------------+
#property strict
#property version   "12.0"
#property description "EA multi-stratégies (checklist, breakout, pullback EMA, SuperTrend, Retest SR, Scalping), gestion risque avancée, panel interactif, bouton fermeture."
#include <Trade\Trade.mqh>
#include <Tradea\PositionInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Math\Stat\Math.mqh>

//--- Paramètres fixes
#define MAX_SYMBOLS 20
#define MAX_RETRIES 3

//=== STRUCTURES ET ENUMS ===//
enum TradeStrategy {
   STRAT_NONE = 0,
   STRAT_CHECKLIST = 1,
   STRAT_BREAKOUT_RANGE = 2,
   STRAT_PULLBACK_EMA = 3,
   STRAT_SUPERTREND = 4,
   STRAT_RETEST_SR = 5,
   STRAT_SCALPING = 6
};
struct TradeSignal {
   bool   valid;
   bool   isBuySignal;
   double price;
   double sl;
   double tp;
   TradeStrategy strategy;
   string comment;
};
static TradeSignal lastSignal;

struct SymbolStats {
   string symbol;
   int totalTrades;
   int winTrades;
   int lossTrades;
   int todayTrades;
   int todayWins;
   int todayLosses;
   double spreadSum;
   int spreadCount;
   double spreadMax;
   double lastSpread;
};
static SymbolStats stats[MAX_SYMBOLS];
static int symbolCount = 0;

struct SyncPrices {
   datetime lastRefresh;
   double ask;
   double bid;
   bool failed;
};
static SyncPrices priceSync;

struct DailyStats {
   int total;
   int wins;
   int losses;
   double pl;
   int consecWins;
   int consecLosses;
};
static DailyStats dayStats;
datetime lastStatsResetTime = 0;

struct SuperTrendData {
   double upperBand;
   double lowerBand;
   bool trendUp;
};
static SuperTrendData stData;

struct SRLevel {
   double price;
   bool isSupport;
   datetime lastTestTime;
};
static SRLevel srLevels[];

//=== PARAMÈTRES UTILISATEUR COMPLETS (Scalping inclus) ===//
input group "Panel Settings"
input color   TextColor = clrWhite;
input color   BgColor = C'30,30,30';
input int     PanelX = 20;
input int     PanelY = 20;
input int     FontSize = 10;
input string  FontName = "Consolas";
input int     RefreshRateSeconds = 5;
input bool    ShowCloseButton = true;
input int     CloseButtonOffset = 10;

input group "Trading Parameters"
input int      MagicNumber       = 456789;
input double   RiskPercent       = 0.5;
input int      MinMinutesBetweenTrades = 5;
input double   MaxSpreadPips     = 30;
input double   MaxSpreadBTCUSD   = 6000;
input double   SpreadAnomalyFactor = 2.5;

input group "Risk Management"
input int      MaxConsecutiveLosses = 3;
input double   MaxLossPercent        = 1.5;
input double   MaxLossPercent60      = 1.0;
input int      MaxHoldMinutes        = 240;
input double   MaxDailyLossPercent = 3.0;
input int      DailyLossWindowHours = 24;
input int      PauseLossCount = 3;
input int      PauseDurationMinutes = 60;
input double   DrawdownLotFactor = 0.5;
input int      ReducedLotTrades = 2;

input group "SL/TP Settings"
input double   ATR_Multiplier_SL = 2.5;
input double   ATR_Multiplier_TP = 1.8;
input int      Min_SL_Pips = 30;
input int      Min_TP_Pips = 20;
input double   Gold_SL_Dollars = 15.0;
input double   Gold_TP_Dollars = 10.0;

input group "Crypto Settings"
input double   BTCUSD_SL_Points_Buy  = 15000;
input double   BTCUSD_SL_Points_Sell = 15000;
input double   BTCUSD_TP_Points_Buy  = 4000;
input double   BTCUSD_TP_Points_Sell = 4000;

input group "Break-Even/Trailing"
input bool     EnableTrailing      = true;
input double   TrailingDistancePips = 100;
input bool     EnableBreakEven      = true;
input double   BreakEvenTrigger     = 0.5;

//--- Handles d'indicateurs
int macdHandle, adxHandle, atrHandle, rsiHandle, bbHandle;
int h4AdxHandle, h4MacdHandle;
int emaHandle, superTrendHandle;

//--- Handles spécifiques Scalping
int scalpingEmaFastHandle = INVALID_HANDLE;
int scalpingEmaSlowHandle = INVALID_HANDLE;
int scalpingAtrHandle     = INVALID_HANDLE;

//--- Objets de trading
CTrade trade;
CPositionInfo positionInfo;
CHistoryOrderInfo historyOrder;
CDealInfo dealInfo;

//--- Variables d'état
bool isBuy = true;
string prefix = "CTP_"+IntegerToString(ChartID());
datetime lastTradeTime = 0;
ulong lastTradeTicket = 0;

//--- Gestion des risques
int consecutiveLosses = 0;
datetime pauseUntil = 0;
bool nextTradesReducedLot = false;
int tradesWithReducedLot = 0;

//--- Interface
int panelWidth = 450;
int panelHeight = 280;
int closeBtnSize = 24;

//=== INPUTS RESTANTS (STRATEGIES, SCALPING) ===//
input group "Indicator Settings"
input int      RSI_Period        = 14;
input double   RSI_Overbought    = 70;
input double   RSI_Oversold      = 30;
input int      MACD_Fast         = 8;
input int      MACD_Slow         = 21;
input int      MACD_Signal       = 9;
input int      BB_Period         = 20;
input double   BB_Deviation      = 2.0;
input int      SuperTrend_Period = 10;
input double   SuperTrend_Multiplier = 3.5;
input int      SR_Lookback       = 100;

input group "Filters"
input bool     UseATRFilter      = true;
input double   MinATRThreshold   = 0.0004;
input double   MaxATRThreshold   = 0.01;
input bool     UseH4TrendFilter  = true;
input int      H4_ADX_Period     = 14;
input double   H4_ADX_Min        = 20;
input bool     UseNewsFilter     = false;
input string   NewsFileName      = "news_eu.csv";

input group "Statistics"
input string   StatsFileName = "EA_STATS.csv";
input bool     EnableTradeLogging = true;
input string   TradeLogFileName = "EA_TRADES.csv";

input group "Advanced Settings"
input bool    EnablePriceSync = true;
input int     MaxPriceRetries = 3;
input int     StatsPanelY = 310;
input color   StatsTextColor = clrWhite;

input group "Multi-Strategies"
input bool EnableBreakoutRange  = true;
input bool EnablePullbackEMA    = true;
input bool EnableSuperTrend     = true;
input bool EnableSRRetest       = true;
input bool EnableScalping       = true;

input int  BreakoutRangeLength  = 20;
input double BreakoutMinATR     = 0.0005;
input double BreakoutRR         = 1.5;

input int  EMA_Period           = 50;
input double EMA_RR             = 1.5;
input int   PullbackLookback    = 5;

input double SuperTrend_RR      = 1.8;
input int    SuperTrend_Confirmation = 2;

input double SR_ZonePct         = 0.5;
input double SR_RR              = 2.0;
input int    SR_Confirmation    = 3;

//--- SCALPING settings
input int    Scalping_EMA_Fast      = 8;
input int    Scalping_EMA_Slow      = 20;
input double Scalping_ATR_Min       = 0.0002;
input double Scalping_Spread_Max    = 15;
input double Scalping_SL_ATR        = 1.2;
input double Scalping_TP_ATR        = 0.8;

//=== FONCTIONS UTILITAIRES ET INITIALISATION ===//
// (la suite commence ici, continue avec la partie 2 !)

//=== FONCTIONS DE GESTION SL/TP, VALIDATION, INIT, SR, INDICATEURS ===//

//--- SL/TP dynamique selon instrument
void GetSLTP(string symbol, bool isBuyTrade, double &sl, double &tp, double entry) {
   if(symbol == "XAUUSD") {
      sl = isBuyTrade ? entry - Gold_SL_Dollars : entry + Gold_SL_Dollars;
      tp = isBuyTrade ? entry + Gold_TP_Dollars : entry - Gold_TP_Dollars;
      if(sl <= 0) sl = entry * (isBuyTrade ? 0.99 : 1.01);
      if(tp <= 0) tp = entry * (isBuyTrade ? 1.01 : 0.99);
   }
   else if(symbol == "BTCUSD") {
      sl = isBuyTrade ? entry - BTCUSD_SL_Points_Buy * _Point : entry + BTCUSD_SL_Points_Sell * _Point;
      tp = isBuyTrade ? entry + BTCUSD_TP_Points_Buy * _Point : entry - BTCUSD_TP_Points_Sell * _Point;
   }
   else {
      double atr = iATR(symbol, _Period, 14);
      sl = isBuyTrade ? entry - atr * ATR_Multiplier_SL : entry + atr * ATR_Multiplier_SL;
      tp = isBuyTrade ? entry + atr * ATR_Multiplier_TP : entry - atr * ATR_Multiplier_TP;
   }
   double minDist = Min_SL_Pips * _Point;
   if(MathAbs(entry - sl) < minDist) sl = isBuyTrade ? entry - minDist : entry + minDist;
}

//--- Validation SL/TP
bool ValidateStopLevels(double price, double sl, double tp, bool isBuyTrade) {
   if(sl <= 0 || tp <= 0) return false;
   double minDist = Min_SL_Pips * _Point;
   if(MathAbs(price - sl) < minDist) return false;
   if((isBuyTrade && tp <= price) || (!isBuyTrade && tp >= price)) return false;
   return true;
}

//--- Initialisation complète
int OnInit() {
   macdHandle = iMACD(_Symbol, _Period, MACD_Fast, MACD_Slow, MACD_Signal, PRICE_CLOSE);
   adxHandle = iADX(_Symbol, _Period, 14);
   atrHandle = iATR(_Symbol, _Period, 14);
   rsiHandle = iRSI(_Symbol, _Period, RSI_Period, PRICE_CLOSE);
   bbHandle  = iBands(_Symbol, _Period, BB_Period, 0, BB_Deviation, PRICE_CLOSE);
   emaHandle = iMA(_Symbol, _Period, EMA_Period, 0, MODE_EMA, PRICE_CLOSE);
   superTrendHandle = iCustom(_Symbol, _Period, "SuperTrend", SuperTrend_Period, SuperTrend_Multiplier);

   if(EnableScalping) {
      scalpingEmaFastHandle = iMA(_Symbol, _Period, Scalping_EMA_Fast, 0, MODE_EMA, PRICE_CLOSE);
      scalpingEmaSlowHandle = iMA(_Symbol, _Period, Scalping_EMA_Slow, 0, MODE_EMA, PRICE_CLOSE);
      scalpingAtrHandle     = iATR(_Symbol, _Period, 14);
   }

   if(UseH4TrendFilter) {
      h4AdxHandle = iADX(_Symbol, PERIOD_H4, H4_ADX_Period);
      h4MacdHandle = iMACD(_Symbol, PERIOD_H4, MACD_Fast, MACD_Slow, MACD_Signal, PRICE_CLOSE);
   }

   if(macdHandle == INVALID_HANDLE || adxHandle == INVALID_HANDLE ||
      atrHandle == INVALID_HANDLE || rsiHandle == INVALID_HANDLE ||
      bbHandle == INVALID_HANDLE || emaHandle == INVALID_HANDLE ||
      superTrendHandle == INVALID_HANDLE ||
      (EnableScalping && (scalpingEmaFastHandle == INVALID_HANDLE || scalpingEmaSlowHandle == INVALID_HANDLE || scalpingAtrHandle == INVALID_HANDLE)) ||
      (UseH4TrendFilter && (h4AdxHandle == INVALID_HANDLE || h4MacdHandle == INVALID_HANDLE))) {
      Alert("Erreur d'initialisation d'un indicateur principal !");
      return INIT_FAILED;
   }

   InitializeStats();
   DetectSRLevels();

   priceSync.ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   priceSync.bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   priceSync.lastRefresh = TimeCurrent();
   priceSync.failed = false;

   ChartSetInteger(0, CHART_EVENT_MOUSE_MOVE, 1);
   EventSetTimer(RefreshRateSeconds);

   DrawStatsPanel();
   DrawBollingerBands();
   DrawCloseButton();

   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetMarginMode();
   trade.SetTypeFillingBySymbol(_Symbol);

   return INIT_SUCCEEDED;
}

//--- Détection des niveaux SR
void DetectSRLevels() {
   ArrayResize(srLevels, 0);
   int lookback = SR_Lookback;
   if(Bars(_Symbol, _Period) < lookback) lookback = Bars(_Symbol, _Period);
   for(int i=3; i<lookback-3; i++) {
      double high1 = iHigh(_Symbol, _Period, i+1);
      double high2 = iHigh(_Symbol, _Period, i);
      double high3 = iHigh(_Symbol, _Period, i-1);
      double low1 = iLow(_Symbol, _Period, i+1);
      double low2 = iLow(_Symbol, _Period, i);
      double low3 = iLow(_Symbol, _Period, i-1);
      if(high2 > high1 && high2 > high3) {
         SRLevel level; level.price = high2; level.isSupport = false; level.lastTestTime = iTime(_Symbol, _Period, i);
         ArrayResize(srLevels, ArraySize(srLevels)+1); srLevels[ArraySize(srLevels)-1] = level;
      }
      if(low2 < low1 && low2 < low3) {
         SRLevel level; level.price = low2; level.isSupport = true; level.lastTestTime = iTime(_Symbol, _Period, i);
         ArrayResize(srLevels, ArraySize(srLevels)+1); srLevels[ArraySize(srLevels)-1] = level;
      }
   }
   // Regroupement des niveaux proches
   for(int i=0; i<ArraySize(srLevels); i++) {
      for(int j=i+1; j<ArraySize(srLevels); j++) {
         double diff = MathAbs(srLevels[i].price - srLevels[j].price);
         double pctDiff = diff / SymbolInfoDouble(_Symbol, SYMBOL_POINT);
         if(pctDiff < (10 * _Point)) {
            srLevels[i].price = (srLevels[i].price + srLevels[j].price) / 2;
            if(srLevels[j].lastTestTime > srLevels[i].lastTestTime)
               srLevels[i].lastTestTime = srLevels[j].lastTestTime;
            for(int k=j; k<ArraySize(srLevels)-1; k++)
               srLevels[k] = srLevels[k+1];
            ArrayResize(srLevels, ArraySize(srLevels)-1);
            j--;
         }
      }
   }
}

//--- Conversion TF en string
string GetTimeframeString(ENUM_TIMEFRAMES tf) {
   switch(tf) {
      case PERIOD_M1: return "M1";
      case PERIOD_M5: return "M5";
      case PERIOD_M15: return "M15";
      case PERIOD_M30: return "M30";
      case PERIOD_H1: return "H1";
      case PERIOD_H4: return "H4";
      case PERIOD_D1: return "D1";
      case PERIOD_W1: return "W1";
      case PERIOD_MN1: return "MN1";
      default: return "M"+IntegerToString(tf);
   }
}

//--- Synchronisation prix marché
bool SyncMarketPrices() {
   if(!EnablePriceSync) return true;
   for(int i=0; i<MaxPriceRetries; i++) {
      if ((TimeCurrent() - SymbolInfoInteger(_Symbol, SYMBOL_TIME)) < (_Symbol=="BTCUSD" ? 0.5 : 1)
          && SymbolInfoDouble(_Symbol, SYMBOL_ASK) > 0) {
         priceSync.ask = SymbolInfoDouble(_Symbol,SYMBOL_ASK);
         priceSync.bid = SymbolInfoDouble(_Symbol,SYMBOL_BID);
         priceSync.lastRefresh = TimeCurrent();
         priceSync.failed = false;
         return true;
      }
      Sleep(100);
   }
   priceSync.failed = true;
   return false;
}

//--- Initialisation stats
void InitializeStats() {
   symbolCount = 0;
   for(int i=0; i<MAX_SYMBOLS; i++) {
      stats[i].symbol = "";
      stats[i].totalTrades = 0;
      stats[i].winTrades = 0;
      stats[i].lossTrades = 0;
      stats[i].todayTrades = 0;
      stats[i].todayWins = 0;
      stats[i].todayLosses = 0;
      stats[i].spreadSum = 0;
      stats[i].spreadCount = 0;
      stats[i].spreadMax = 0;
      stats[i].lastSpread = 0;
   }
   LoadStatsFromFile();
   lastStatsResetTime = GetToday0();
}

//--- Timestamp début du jour
datetime GetToday0() {
   MqlDateTime dt;
   TimeToStruct(TimeCurrent(), dt);
   dt.hour = 0; dt.min = 0; dt.sec = 0;
   return StructToTime(dt);
}

//--- Réinitialisation stats du jour si besoin
void ResetTodayStatsIfNeeded() {
   datetime currDay0 = GetToday0();
   if(currDay0 > lastStatsResetTime) {
      for(int i=0; i<symbolCount; i++) {
         stats[i].todayTrades = 0;
         stats[i].todayWins = 0;
         stats[i].todayLosses = 0;
      }
      lastStatsResetTime = currDay0;
      SaveStatsToFile();
   }
}

//--- Chargement stats depuis fichier
void LoadStatsFromFile() {
   int handle = FileOpen(StatsFileName, FILE_READ|FILE_CSV|FILE_ANSI, ';');
   if(handle == INVALID_HANDLE) return;
   while(!FileIsEnding(handle)) {
      string line = FileReadString(handle);
      string parts[];
      StringSplit(line, ';', parts);
      if(ArraySize(parts) >= 10) {
         int idx = -1;
         for(int i=0; i<symbolCount; i++) {
            if(stats[i].symbol == parts[0]) { idx = i; break; }
         }
         if(idx == -1 && symbolCount < MAX_SYMBOLS) { idx = symbolCount; symbolCount++; }
         if(idx != -1) {
            stats[idx].symbol = parts[0];
            stats[idx].totalTrades = (int)StringToInteger(parts[1]);
            stats[idx].winTrades = (int)StringToInteger(parts[2]);
            stats[idx].lossTrades = (int)StringToInteger(parts[3]);
            stats[idx].todayTrades = (int)StringToInteger(parts[4]);
            stats[idx].todayWins = (int)StringToInteger(parts[5]);
            stats[idx].todayLosses = (int)StringToInteger(parts[6]);
            stats[idx].spreadSum = StringToDouble(parts[7]);
            stats[idx].spreadCount = (int)StringToInteger(parts[8]);
            stats[idx].spreadMax = StringToDouble(parts[9]);
            stats[idx].lastSpread = StringToDouble(parts[10]);
         }
      }
   }
   FileClose(handle);
}

//--- Sauvegarde stats dans fichier
void SaveStatsToFile() {
   int handle = FileOpen(StatsFileName, FILE_WRITE|FILE_CSV|FILE_ANSI, ';');
   if(handle == INVALID_HANDLE) return;
   for(int i=0; i<symbolCount; i++) {
      string line = StringFormat("%s;%d;%d;%d;%d;%d;%d;%f;%d;%f;%f",
         stats[i].symbol,
         stats[i].totalTrades,
         stats[i].winTrades,
         stats[i].lossTrades,
         stats[i].todayTrades,
         stats[i].todayWins,
         stats[i].todayLosses,
         stats[i].spreadSum,
         stats[i].spreadCount,
         stats[i].spreadMax,
         stats[i].lastSpread);
      FileWrite(handle, line);
   }
   FileClose(handle);
}

//--- Détection SuperTrend
bool DetectSuperTrendSignal(TradeSignal &signal) {
   signal.valid = false;
   double stUpper[], stLower[];
   if(CopyBuffer(superTrendHandle, 0, 1, 3, stUpper) != 3 || 
      CopyBuffer(superTrendHandle, 1, 1, 3, stLower) != 3)
      return false;
   double close1 = iClose(_Symbol, _Period, 1);
   double close2 = iClose(_Symbol, _Period, 2);
   if(close2 <= stLower[1] && close1 > stLower[0]) {
      signal.valid = true;
      signal.isBuySignal = true;
      signal.strategy = STRAT_SUPERTREND;
      signal.price = priceSync.ask;
      signal.sl = MathMax(stLower[0], 0.00001);
      signal.tp = signal.price + MathAbs(signal.price - signal.sl) * SuperTrend_RR;
      signal.comment = "SuperTrend Buy Signal";
      return ValidateStopLevels(signal.price, signal.sl, signal.tp, true);
   }
   if(close2 >= stUpper[1] && close1 < stUpper[0]) {
      signal.valid = true;
      signal.isBuySignal = false;
      signal.strategy = STRAT_SUPERTREND;
      signal.price = priceSync.bid;
      signal.sl = stUpper[0];
      signal.tp = signal.price - MathAbs(signal.sl - signal.price) * SuperTrend_RR;
      signal.comment = "SuperTrend Sell Signal";
      return ValidateStopLevels(signal.price, signal.sl, signal.tp, false);
   }
   return false;
}

//--- Détection Retest SR
bool DetectSRRetestSignal(TradeSignal &signal) {
   signal.valid = false;
   if(ArraySize(srLevels) == 0) return false;
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double atrVal = iATR(_Symbol, _Period, 14);
   for(int i=0; i<ArraySize(srLevels); i++) {
      double distance = MathAbs((ask + bid)/2 - srLevels[i].price);
      double zoneSize = atrVal * SR_ZonePct;
      if(distance <= zoneSize) {
         bool confirmed = true;
         for(int j=1; j<=SR_Confirmation; j++) {
            double prevClose = iClose(_Symbol, _Period, j);
            if(srLevels[i].isSupport) {
               if(prevClose < srLevels[i].price - zoneSize) confirmed = false;
            } else {
               if(prevClose > srLevels[i].price + zoneSize) confirmed = false;
            }
         }
         if(confirmed) {
            signal.valid = true;
            signal.strategy = STRAT_RETEST_SR;
            signal.comment = srLevels[i].isSupport ? "Support Retest" : "Resistance Retest";
            if(srLevels[i].isSupport) {
               signal.isBuySignal = true;
               signal.price = ask;
               signal.sl = srLevels[i].price - zoneSize * 1.5;
               signal.tp = signal.price + (signal.price - signal.sl) * SR_RR;
            } else {
               signal.isBuySignal = false;
               signal.price = bid;
               signal.sl = srLevels[i].price + zoneSize * 1.5;
               signal.tp = signal.price - (signal.sl - signal.price) * SR_RR;
            }
            return ValidateStopLevels(signal.price, signal.sl, signal.tp, signal.isBuySignal);
         }
      }
   }
   return false;
}

//--- Détection Breakout Range
bool DetectBreakoutSignal(TradeSignal &signal) {
    signal.valid = false;
    int bars = BreakoutRangeLength;
    if(Bars(_Symbol, _Period) <= bars+2) return false;
    double highest = -DBL_MAX, lowest = DBL_MAX;
    for(int i=1; i<=bars; i++) {
        double hi = iHigh(_Symbol, _Period, i);
        double lo = iLow(_Symbol, _Period, i);
        if(hi > highest) highest = hi;
        if(lo < lowest) lowest = lo;
    }
    double currClose = iClose(_Symbol, _Period, 0);
    double prevClose = iClose(_Symbol, _Period, 1);
    double atrVal = iATR(_Symbol, _Period, 14);
    if(atrVal < BreakoutMinATR) return false;
    if((currClose > highest) && (prevClose <= highest)) {
        signal.valid = true;
        signal.isBuySignal = true;
        signal.strategy = STRAT_BREAKOUT_RANGE;
        signal.price = priceSync.ask;
        double sl = lowest;
        double tp = signal.price + (signal.price - sl) * BreakoutRR;
        signal.sl = sl;
        signal.tp = tp;
        signal.comment = "Breakout Buy Signal";
        return ValidateStopLevels(signal.price, signal.sl, signal.tp, true);
    }
    else if((currClose < lowest) && (prevClose >= lowest)) {
        signal.valid = true;
        signal.isBuySignal = false;
        signal.strategy = STRAT_BREAKOUT_RANGE;
        signal.price = priceSync.bid;
        double sl = highest;
        double tp = signal.price - (sl - signal.price) * BreakoutRR;
        signal.sl = sl;
        signal.tp = tp;
        signal.comment = "Breakout Sell Signal";
        return ValidateStopLevels(signal.price, signal.sl, signal.tp, false);
    }
    return false;
}

//--- Détection Pullback EMA
bool DetectPullbackEMASignal(TradeSignal &signal) {
    signal.valid = false;
    int lookback = PullbackLookback;
    double emaBuff[];
    if(CopyBuffer(emaHandle, 0, 0, lookback+2, emaBuff) != lookback+2) return false;
    double currClose = iClose(_Symbol, _Period, 0);
    for(int i=1; i<=lookback; i++) {
        double close_i = iClose(_Symbol, _Period, i);
        if((close_i < emaBuff[i]) && (currClose > emaBuff[0])) {
            signal.valid = true;
            signal.isBuySignal = true;
            signal.strategy = STRAT_PULLBACK_EMA;
            signal.price = priceSync.ask;
            double sl = emaBuff[0] - (emaBuff[0] - iLow(_Symbol, _Period, i));
            double tp = signal.price + (signal.price - sl) * EMA_RR;
            signal.sl = sl;
            signal.tp = tp;
            signal.comment = "EMA Pullback Buy";
            return ValidateStopLevels(signal.price, signal.sl, signal.tp, true);
        }
    }
    for(int i=1; i<=lookback; i++) {
        double close_i = iClose(_Symbol, _Period, i);
        if((close_i > emaBuff[i]) && (currClose < emaBuff[0])) {
            signal.valid = true;
            signal.isBuySignal = false;
            signal.strategy = STRAT_PULLBACK_EMA;
            signal.price = priceSync.bid;
            double sl = emaBuff[0] + (iHigh(_Symbol, _Period, i) - emaBuff[0]);
            double tp = signal.price - (sl - signal.price) * EMA_RR;
            signal.sl = sl;
            signal.tp = tp;
            signal.comment = "EMA Pullback Sell";
            return ValidateStopLevels(signal.price, signal.sl, signal.tp, false);
        }
    }
    return false;
}

//--- Détection SCALPING (entrée rapide, spread faible, EMA, ATR, etc.)
bool DetectScalpingSignal(TradeSignal &signal) {
   signal.valid = false;
   if(!EnableScalping) return false;
   double spreadPoints = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / _Point;
   if(spreadPoints > Scalping_Spread_Max) return false;
   double atrVal = 0.0;
   if(scalpingAtrHandle != INVALID_HANDLE) {
      double atrArr[]; if(CopyBuffer(scalpingAtrHandle, 0, 0, 1, atrArr)==1) atrVal = atrArr[0];
   } else {
      atrVal = iATR(_Symbol, _Period, 14);
   }
   if(atrVal < Scalping_ATR_Min) return false;
   double emaFast=0, emaSlow=0;
   if(scalpingEmaFastHandle != INVALID_HANDLE) {
      double emaF[]; if(CopyBuffer(scalpingEmaFastHandle, 0, 0, 1, emaF)==1) emaFast = emaF[0];
   } else { emaFast = iMA(_Symbol, _Period, Scalping_EMA_Fast, 0, MODE_EMA, PRICE_CLOSE); }
   if(scalpingEmaSlowHandle != INVALID_HANDLE) {
      double emaS[]; if(CopyBuffer(scalpingEmaSlowHandle, 0, 0, 1, emaS)==1) emaSlow = emaS[0];
   } else { emaSlow = iMA(_Symbol, _Period, Scalping_EMA_Slow, 0, MODE_EMA, PRICE_CLOSE); }
   double lastClose = iClose(_Symbol, _Period, 1);
   double currClose = iClose(_Symbol, _Period, 0);
   if(currClose > emaFast && emaFast > emaSlow && currClose > lastClose) {
      signal.valid = true;
      signal.isBuySignal = true;
      signal.strategy = STRAT_SCALPING;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      signal.sl = signal.price - atrVal * Scalping_SL_ATR;
      signal.tp = signal.price + atrVal * Scalping_TP_ATR;
      signal.comment = "Scalping Buy";
      return ValidateStopLevels(signal.price, signal.sl, signal.tp, true);
   }
   if(currClose < emaFast && emaFast < emaSlow && currClose < lastClose) {
      signal.valid = true;
      signal.isBuySignal = false;
      signal.strategy = STRAT_SCALPING;
      signal.price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      signal.sl = signal.price + atrVal * Scalping_SL_ATR;
      signal.tp = signal.price - atrVal * Scalping_TP_ATR;
      signal.comment = "Scalping Sell";
      return ValidateStopLevels(signal.price, signal.sl, signal.tp, false);
   }
   return false;
}

//--- Checklist stratégie principale
bool ChecklistStrategySignal(TradeSignal &signal) {
    bool macdOk = IsMACDAligned();
    bool rsiOk = NoCounterSignal();
    bool trendOk = IsTrending();
    bool h4TrendOk = IsH4TrendOk();
    bool volatileOk = IsVolatile();
    bool bbOk = IsPriceNearBollingerBand();
    int confirmations = 0;
    if(macdOk) confirmations++;
    if(rsiOk) confirmations++;
    if(trendOk) confirmations++;
    if(h4TrendOk) confirmations++;
    if(volatileOk) confirmations++;
    if(bbOk) confirmations++;
    if(confirmations >= 5) {
        DetectMarketDirection();
        signal.valid = true;
        signal.isBuySignal = isBuy;
        signal.strategy = STRAT_CHECKLIST;
        signal.price = isBuy ? priceSync.ask : priceSync.bid;
        double sl=0, tp=0;
        GetSLTP(_Symbol, isBuy, sl, tp, signal.price);
        signal.sl = sl;
        signal.tp = tp;
        signal.comment = "Checklist Strategy";
        return ValidateStopLevels(signal.price, signal.sl, signal.tp, isBuy);
    }
    signal.valid = false;
    return false;
}

//--- Nom de la stratégie (panel)
string StrategyName(TradeStrategy strat) {
   switch(strat) {
      case STRAT_NONE: return "--";
      case STRAT_CHECKLIST: return "Checklist";
      case STRAT_BREAKOUT_RANGE: return "BreakoutRange";
      case STRAT_PULLBACK_EMA: return "PullbackEMA";
      case STRAT_SUPERTREND: return "SuperTrend";
      case STRAT_RETEST_SR: return "RetestSR";
      case STRAT_SCALPING: return "Scalping";
      default: return "Inconnue";
   }
}

//--- Vérif MACD aligné
bool IsMACDAligned() {
   double macd[], signal[];
   if(CopyBuffer(macdHandle, MAIN_LINE, 0, 2, macd) != 2 || CopyBuffer(macdHandle, SIGNAL_LINE, 0, 2, signal) != 2)
      return false;
   if(macd[0] > signal[0] && macd[1] > signal[1])
      return true;
   if(macd[0] < signal[0] && macd[1] < signal[1])
      return true;
   return false;
}

//--- Vérif RSI pas de contre signal
bool NoCounterSignal() {
   double rsi[];
   if(CopyBuffer(rsiHandle, 0, 0, 2, rsi) != 2)
      return false;
   if(rsi[0] > RSI_Overbought || rsi[0] < RSI_Oversold)
      return false;
   return true;
}

//--- Vérif tendance ADX
bool IsTrending() {
   double adx[];
   if(CopyBuffer(adxHandle, 0, 0, 1, adx) != 1)
      return false;
   return adx[0] > 25;
}

//--- Vérif tendance H4
bool IsH4TrendOk() {
   if(!UseH4TrendFilter) return true;
   double h4Adx[];
   if(CopyBuffer(h4AdxHandle, 0, 0, 1, h4Adx) != 1)
      return false;
   return h4Adx[0] > H4_ADX_Min;
}

//--- Vérif volatilité ATR
bool IsVolatile() {
   if(!UseATRFilter) return true;
   double atr[];
   if(CopyBuffer(atrHandle, 0, 0, 1, atr) != 1)
      return false;
   return atr[0] >= MinATRThreshold && atr[0] <= MaxATRThreshold;
}

//--- Vérif prix proche BB
bool IsPriceNearBollingerBand() {
   double upper[], lower[], close[];
   if(CopyBuffer(bbHandle, UPPER_BAND, 0, 1, upper) != 1 || 
      CopyBuffer(bbHandle, LOWER_BAND, 0, 1, lower) != 1 ||
      CopyClose(_Symbol, _Period, 0, 1, close) != 1)
      return false;
   double distanceToUpper = upper[0] - close[0];
   double distanceToLower = close[0] - lower[0];
   double atr = iATR(_Symbol, _Period, 14);
   return distanceToUpper < atr || distanceToLower < atr;
}

//--- Détection direction marché
void DetectMarketDirection() {
   double macd[], signal[];
   if(CopyBuffer(macdHandle, MAIN_LINE, 0, 1, macd) == 1 && CopyBuffer(macdHandle, SIGNAL_LINE, 0, 1, signal) == 1) {
      isBuy = macd[0] > signal[0];
   }
}

//--- Vérifie conditions trading (toutes strat)
bool CheckTradingConditions(TradeSignal &signal) {
   if(pauseUntil > TimeCurrent()) return false;
   if(HasOpenPosition()) return false;
   if(CountOpenTradesForSymbol(_Symbol, MagicNumber) >= 3) return false;
   if(!IsSpreadValid()) return false;
   if(IsMaxDailyLossReached()) return false;
   if(IsNewsTime()) return false;
   if((TimeCurrent() - lastTradeTime) < MinMinutesBetweenTrades*60) return false;
   TradeSignal sig;
   sig.valid = false;
   if(EnableSuperTrend && DetectSuperTrendSignal(sig)) {
      signal = sig;
      return true;
   }
   if(EnableSRRetest && DetectSRRetestSignal(sig)) {
      signal = sig;
      return true;
   }
   if(EnableBreakoutRange && DetectBreakoutSignal(sig)) {
      signal = sig;
      return true;
   }
   if(EnablePullbackEMA && DetectPullbackEMASignal(sig)) {
      signal = sig;
      return true;
   }
   if(ChecklistStrategySignal(sig)) {
      signal = sig;
      return true;
   }
   if(EnableScalping && DetectScalpingSignal(sig)) {
      signal = sig;
      return true;
   }
   return false;
}

//--- Avoir position ouverte pour ce symbole/magic
bool HasOpenPosition() {
   for(int i=PositionsTotal()-1; i>=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionGetString(POSITION_SYMBOL)==_Symbol && PositionGetInteger(POSITION_MAGIC)==MagicNumber)
         return true;
   }
   return false;
}

//--- Compter trades ouverts
int CountOpenTradesForSymbol(string symbol, int magic) {
   int count=0;
   for(int i=PositionsTotal()-1; i>=0; i--) {
      if(PositionGetString(POSITION_SYMBOL)==symbol && PositionGetInteger(POSITION_MAGIC)==magic)
         count++;
   }
   return count;
}

//--- Vérif spread
bool IsSpreadValid() {
   double spr = (SymbolInfoDouble(_Symbol,SYMBOL_ASK)-SymbolInfoDouble(_Symbol,SYMBOL_BID))/SymbolInfoDouble(_Symbol,SYMBOL_POINT);
   if(_Symbol=="BTCUSD")
      return spr<=MaxSpreadBTCUSD;
   else
      return spr<=MaxSpreadPips;
}

//--- Vérif drawdown max journalier
bool IsMaxDailyLossReached() {
   if(dayStats.pl < -AccountInfoDouble(ACCOUNT_BALANCE) * MaxDailyLossPercent/100.0)
      return true;
   return false;
}

//--- News (placeholder)
bool IsNewsTime() { return false; }

//--- Calcul taille lot par risque
double CalculateLotSize(double slInPoints) {
   double risk = AccountInfoDouble(ACCOUNT_BALANCE) * RiskPercent / 100.0;
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double contractSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_CONTRACT_SIZE);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   if(slInPoints <= 0.0 || tickValue <= 0.0 || tickSize <= 0.0)
      return lotStep;
   double lot = risk / (slInPoints * tickValue / tickSize);
   lot = MathMax(lot, lotStep);
   lot = MathFloor(lot / lotStep) * lotStep;
   return NormalizeDouble(lot, 2);
}

//--- Ouvre un trade
void OpenTrade(const TradeSignal &signal) {
   if(!signal.valid || !ValidateStopLevels(signal.price, signal.sl, signal.tp, signal.isBuySignal)) {
      Print("Ordre annulé: stops invalides. SL:", signal.sl, " TP:", signal.tp);
      return;
   }
   double lotSize = CalculateLotSize(MathAbs(signal.price - signal.sl) / _Point);
   trade.SetExpertMagicNumber(MagicNumber);
   bool success = signal.isBuySignal
      ? trade.Buy(lotSize, _Symbol, signal.price, signal.sl, signal.tp, "STRAT_"+IntegerToString(signal.strategy))
      : trade.Sell(lotSize, _Symbol, signal.price, signal.sl, signal.tp, "STRAT_"+IntegerToString(signal.strategy));
   if(success) {
      lastTradeTime = TimeCurrent();
      lastTradeTicket = trade.ResultOrder();
      if(EnableTradeLogging)
         LogTrade(signal.isBuySignal, signal.price, signal.sl, signal.tp, lotSize, signal.strategy);
      Print("Trade ouvert (", StrategyName(signal.strategy), "): ", signal.isBuySignal?"BUY":"SELL", " Lot:", lotSize, " SL:", signal.sl, " TP:", signal.tp);
   }
   else {
      Print("Échec de l'ouverture: ", GetLastError());
   }
}

//--- Log trade
void LogTrade(bool tradeIsBuy, double entry, double sl, double tp, double lotSize, TradeStrategy strat) {
   int handle = FileOpen(TradeLogFileName, FILE_WRITE|FILE_CSV|FILE_ANSI);
   if(handle == INVALID_HANDLE) return;
   FileSeek(handle, 0, SEEK_END);
   if(FileTell(handle) == 0)
      FileWrite(handle, "DateTime,Symbol,Type,Entry,SL,TP,LotSize,Balance,Equity,Strategy");
   FileWrite(handle,
      TimeToString(TimeCurrent(), TIME_DATE|TIME_MINUTES), _Symbol,
      tradeIsBuy ? "BUY" : "SELL",
      entry, sl, tp, lotSize,
      AccountInfoDouble(ACCOUNT_BALANCE), AccountInfoDouble(ACCOUNT_EQUITY),
      StrategyName(strat)
   );
   FileClose(handle);
}

void UpdateTradeStats() {
   datetime dayStart = iTime(_Symbol, PERIOD_D1, 0);
   HistorySelect(dayStart, TimeCurrent());

   dayStats.total = 0;
   dayStats.wins = 0;
   dayStats.losses = 0;
   dayStats.pl = 0;
   dayStats.consecWins = 0;
   dayStats.consecLosses = 0;

   for(int i = HistoryDealsTotal() - 1; i >= 0; i--) {
      ulong ticket = HistoryDealGetTicket(i);
      if(!HistoryDealSelect(ticket)) continue;

      if(HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT)
         continue;

      string sym = HistoryDealGetString(ticket, DEAL_SYMBOL);
      if(sym != _Symbol)
         continue;

      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
      dayStats.total++;
      dayStats.pl += profit;

      if(profit > 0) {
         dayStats.wins++;
         dayStats.consecWins++;
         dayStats.consecLosses = 0;
      } else {
         dayStats.losses++;
         dayStats.consecLosses++;
         dayStats.consecWins = 0;
      }
   }
}

// --- Calcul dynamique des stats journalières pour affichage
void UpdateDayStats() {
    // Obtenir le début de la journée broker (identique au rapport MT5/Excel)
    datetime dayStart = iTime(_Symbol, PERIOD_D1, 0);
    HistorySelect(dayStart, TimeCurrent());

    dayStats.total = 0;
    dayStats.wins = 0;
    dayStats.losses = 0;
    dayStats.pl = 0.0;
    dayStats.consecWins = 0;
    dayStats.consecLosses = 0;

    for (int i = HistoryDealsTotal() - 1; i >= 0; i--) {
        ulong ticket = HistoryDealGetTicket(i);
        if (HistoryDealGetInteger(ticket, DEAL_ENTRY) != DEAL_ENTRY_OUT)
            continue; // On ne compte que les deals de clôture

        double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);

        // *** NE PAS filtrer sur le symbole pour avoir le total tous symboles ***
        dayStats.total++;
        dayStats.pl += profit;
        if (profit > 0) {
            dayStats.wins++;
            dayStats.consecWins++;
            dayStats.consecLosses = 0;
        } else {
            dayStats.losses++;
            dayStats.consecLosses++;
            dayStats.consecWins = 0;
        }
    }
}

//--- Gestion panel stats (bouton fermeture inclus)
void DrawStatsPanel() {
   UpdateDayStats();
   // SUPPRIME ces 5 lignes dupliquées plus bas ! (elles sont redéclarées plus bas)
   // int tradesToday = dayStats.total;
   // int winsToday   = dayStats.wins;
   // int lossesToday = dayStats.losses;
   // double plToday  = dayStats.pl;
   // double winRate  = (tradesToday > 0) ? (100.0 * winsToday / tradesToday) : 0.0;

   string localPrefix = "EA_STATS_";
   string panelName = localPrefix + "MAIN";
   if(ObjectFind(0, panelName) < 0) {
      ObjectCreate(0, panelName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
      ObjectSetInteger(0, panelName, OBJPROP_XDISTANCE, PanelX);
      ObjectSetInteger(0, panelName, OBJPROP_YDISTANCE, PanelY);
      ObjectSetInteger(0, panelName, OBJPROP_XSIZE, panelWidth);
      ObjectSetInteger(0, panelName, OBJPROP_YSIZE, panelHeight);
      ObjectSetInteger(0, panelName, OBJPROP_BGCOLOR, BgColor);
      ObjectSetInteger(0, panelName, OBJPROP_BORDER_TYPE, BORDER_FLAT);
      ObjectSetInteger(0, panelName, OBJPROP_BORDER_COLOR, clrWhite);
      ObjectSetInteger(0, panelName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, panelName, OBJPROP_BACK, false);
      ObjectSetInteger(0, panelName, OBJPROP_SELECTABLE, false);
      ObjectSetInteger(0, panelName, OBJPROP_HIDDEN, false);
      ObjectSetInteger(0, panelName, OBJPROP_ZORDER, 0);
   }
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double profit = AccountInfoDouble(ACCOUNT_PROFIT);
   double currentSpread = (SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID)) / _Point;
   // Utilise les variables calculées UNE seule fois ici :
   int tradesToday = dayStats.total;
   int winsToday   = dayStats.wins;
   int lossesToday = dayStats.losses;
   double plToday  = dayStats.pl;
   double winRate  = (tradesToday > 0) ? (100.0 * winsToday / tradesToday) : 0.0;
   int y = PanelY + 10;
   CreateOrUpdateLabel(localPrefix+"HEADER",   PanelX+10, y,  "SBS DIAMOND v12.0", clrGold, 14); y += 22;
   CreateOrUpdateLabel(localPrefix+"SYMBOL",   PanelX+10, y,  "Symbole: " + _Symbol + " | TF: " + GetTimeframeString(_Period), clrWhite, 10); y += 18;

   string activeStrategy = "--";
   datetime latestTime = 0;
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if (PositionSelectByTicket(ticket)) {
         string sym = PositionGetString(POSITION_SYMBOL);
         int magic = (int)PositionGetInteger(POSITION_MAGIC);
         datetime opentime = (datetime)PositionGetInteger(POSITION_TIME);
         if (sym == _Symbol && magic == MagicNumber && opentime > latestTime) {
            string comment = PositionGetString(POSITION_COMMENT);
            if (StringFind(comment, "STRAT_") == 0) {
               int stratCode = (int)StringToInteger(StringSubstr(comment, 6));
               activeStrategy = StrategyName((TradeStrategy)stratCode);
               latestTime = opentime;
            }
         }
      }
   }
   CreateOrUpdateLabel(localPrefix+"STRATEGY", PanelX+10, y,  "Stratégie active: " + activeStrategy, clrWhite, 10); y += 18;
   CreateOrUpdateLabel(localPrefix+"BALANCE",  PanelX+10, y,  "Solde: " + DoubleToString(balance, 2) + " USD", clrWhite, 10); y += 18;
   CreateOrUpdateLabel(localPrefix+"EQUITY",   PanelX+10, y,  "Equité: " + DoubleToString(equity, 2) + " USD", equity >= balance ? clrLime : clrOrange, 10); y += 18;
   CreateOrUpdateLabel(localPrefix+"PROFIT",   PanelX+10, y,  "Profit: " + DoubleToString(profit, 2) + " USD", profit >= 0 ? clrLime : clrOrange, 10); y += 18;
   CreateOrUpdateLabel(localPrefix+"SPREAD",   PanelX+10, y,  "Spread actuel: " + DoubleToString(currentSpread, 1) + " pts", clrAqua, 10); y += 18;
   CreateOrUpdateLabel(localPrefix+"STATS_HEADER",  PanelX+10, y, "-- Statistiques Journalières --", clrLightSkyBlue, 11); y += 18;
   CreateOrUpdateLabel(localPrefix+"TRADES_TODAY",  PanelX+10, y, "Trades aujourd'hui: " + IntegerToString(tradesToday), clrWhite, 10); y += 16;
   CreateOrUpdateLabel(localPrefix+"WINS_TODAY",    PanelX+10, y, "Trades gagnants:   " + IntegerToString(winsToday), clrLime, 10); y += 16;
   CreateOrUpdateLabel(localPrefix+"LOSSES_TODAY",  PanelX+10, y, "Trades perdants:   " + IntegerToString(lossesToday), clrOrange, 10); y += 16;
   CreateOrUpdateLabel(localPrefix+"PROFIT_TODAY",  PanelX+10, y, "P/L du jour:       " + DoubleToString(plToday, 2) + " USD", plToday >= 0 ? clrLime : clrOrange, 10); y += 20;
   CreateOrUpdateLabel(localPrefix+"WINRATE",  PanelX+10, y,  "Win rate: " + DoubleToString(winRate, 1) + " %", clrYellow, 12); y += 18;

   string pauseStatus = (pauseUntil > TimeCurrent()) ? "PAUSE (jusqu'à " + TimeToString(pauseUntil) + ")" : "ACTIF";
   CreateOrUpdateLabel(localPrefix+"PAUSE", PanelX+10, y, "Statut: " + pauseStatus, pauseUntil > TimeCurrent() ? clrOrange : clrLime, 11); y += 20;
   DrawCloseButton();
}

//--- Crée ou met à jour un label
void CreateOrUpdateLabel(string name, int x, int y, string txt, color c, int fontSize=10) {
   if(ObjectFind(0, name) < 0) {
      ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, name, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   }
   ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
   ObjectSetString(0, name, OBJPROP_TEXT, txt);
   ObjectSetInteger(0, name, OBJPROP_COLOR, c);
   ObjectSetInteger(0, name, OBJPROP_FONTSIZE, fontSize);
   ObjectSetString(0, name, OBJPROP_FONT, FontName);
}

//--- Dessin du bouton de fermeture
void DrawCloseButton() {
   if(!ShowCloseButton) return;
   string closeName = prefix+"_CLOSE_BTN";
   int btnX = PanelX + panelWidth - closeBtnSize - CloseButtonOffset;
   int btnY = PanelY + CloseButtonOffset;
   if(ObjectFind(0, closeName) < 0)
      ObjectCreate(0, closeName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, closeName, OBJPROP_XDISTANCE, btnX);
   ObjectSetInteger(0, closeName, OBJPROP_YDISTANCE, btnY);
   ObjectSetInteger(0, closeName, OBJPROP_XSIZE, closeBtnSize);
   ObjectSetInteger(0, closeName, OBJPROP_YSIZE, closeBtnSize);
   ObjectSetInteger(0, closeName, OBJPROP_BGCOLOR, clrRed);
   ObjectSetInteger(0, closeName, OBJPROP_CORNER, CORNER_LEFT_UPPER);
   ObjectSetInteger(0, closeName, OBJPROP_SELECTABLE, true);
   ObjectSetInteger(0, closeName, OBJPROP_ZORDER, 4000);
   ObjectSetString(0, closeName, OBJPROP_TEXT, "X");
   ObjectSetInteger(0, closeName, OBJPROP_COLOR, clrWhite);
}

//--- Gestion de l'événement click sur le bouton de fermeture
void OnChartEvent(const int id, const long &lparam, const double &dparam, const string &sparam) {
   if(id == CHARTEVENT_OBJECT_CLICK) {
      if(StringFind(sparam, prefix+"_CLOSE_BTN") != -1) {
         ExpertRemove();
         return;
      }
   }
}

//--- Trailing, break-even, gestion active avancée, OnTick, OnTimer, finalisation

//--- Trailing Stop & Break-Even multi-stratégies
void ManageActiveTrades() {
   for (int i = PositionsTotal() - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if (PositionSelectByTicket(ticket)) {
         string sym = PositionGetString(POSITION_SYMBOL);
         if (sym != _Symbol) continue;
         int magic = (int)PositionGetInteger(POSITION_MAGIC);
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double sl = PositionGetDouble(POSITION_SL);
         double tp = PositionGetDouble(POSITION_TP);
         double vol = PositionGetDouble(POSITION_VOLUME);
         int type = (int)PositionGetInteger(POSITION_TYPE);
         double price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(sym, SYMBOL_BID) : SymbolInfoDouble(sym, SYMBOL_ASK);
         double point = SymbolInfoDouble(sym, SYMBOL_POINT);
         double distanceToTP = MathAbs(tp - entry);
         double trailingDistance = TrailingDistancePips * point;

         // Break-even
         if (EnableBreakEven && tp > 0 && distanceToTP > 0) {
            double triggerPrice = (type == POSITION_TYPE_BUY) ? entry + distanceToTP * BreakEvenTrigger
                                                              : entry - distanceToTP * BreakEvenTrigger;
            bool triggerReached = (type == POSITION_TYPE_BUY) ? (price >= triggerPrice) : (price <= triggerPrice);
            bool slBehindEntry = (type == POSITION_TYPE_BUY) ? (sl < entry) : (sl > entry);

            if (triggerReached && slBehindEntry) {
               double newSL = entry;
               trade.PositionModify(ticket, newSL, tp);
               LogEvent("BreakEven", "Break-even moved for " + sym);
            }
         }

         // Trailing
         if (EnableTrailing && trailingDistance > 0) {
            double newSL = 0;
            bool shouldTrail = false;

            if (type == POSITION_TYPE_BUY) {
               double trailLevel = price - trailingDistance;
               if (trailLevel > sl && price - entry > trailingDistance) {
                  newSL = trailLevel;
                  shouldTrail = true;
               }
            }
            else if (type == POSITION_TYPE_SELL) {
               double trailLevel = price + trailingDistance;
               if (trailLevel < sl && entry - price > trailingDistance) {
                  newSL = trailLevel;
                  shouldTrail = true;
               }
            }

            if (shouldTrail) {
               trade.PositionModify(ticket, newSL, tp);
               LogEvent("Trailing", "Trailing stop updated for " + sym);
            }
         }
      }
   }
}

//--- Trading partiel et clôture semi-automatique
void ManagePartialClose() {
   for(int i=PositionsTotal()-1; i>=0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string sym = PositionGetString(POSITION_SYMBOL);
         int magic = (int)PositionGetInteger(POSITION_MAGIC);
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double tp = PositionGetDouble(POSITION_TP);
         double vol = PositionGetDouble(POSITION_VOLUME);
         int type = (int)PositionGetInteger(POSITION_TYPE);
         double price = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(sym, SYMBOL_BID) : SymbolInfoDouble(sym, SYMBOL_ASK);
         if(tp > 0 && vol > 0.01) {
            double halfway = (type == POSITION_TYPE_BUY) ? (entry + (tp - entry) * 0.5) : (entry - (entry - tp) * 0.5);
            if((type == POSITION_TYPE_BUY && price >= halfway) || (type == POSITION_TYPE_SELL && price <= halfway)) {
               double closeVol = MathMax(0.01, vol/2.0);
               trade.PositionClosePartial(ticket, closeVol);
               LogEvent("PartialClose", "Closed half position on " + sym);
            }
         }
      }
   }
}

//--- Gestion OnTick
void OnTick() {
   if (IsNewsTime()) return;
   ManageActiveTrades();
   ManagePartialClose();
   static datetime lastUpdate = 0;
   if(TimeCurrent() - lastUpdate >= 60) {
      DrawBollingerBands();
      lastUpdate = TimeCurrent();
   }
   if(!SyncMarketPrices()) return;

   //UpdateTradeStats();
   UpdateDayStats();  
   ResetTodayStatsIfNeeded();
   DrawStatsPanel();

   TradeSignal signal;
   if(CheckTradingConditions(signal)) {
      OpenTrade(signal);
   }
   if(TimeCurrent()%10==0) DrawStatsPanel();
}

//--- Gestion OnTimer
void OnTimer() {
   DrawStatsPanel();
   DrawCloseButton();
}

//--- Bollinger Bands visuel
void DrawBollingerBands() {
   // Désactivé pour éviter de polluer le graphique avec 300 lignes !
}

//--- Gestion logs centralisé
void LogEvent(string context, string msg) {
   int handle = FileOpen("EA_EVENTS.csv", FILE_WRITE|FILE_CSV|FILE_ANSI);
   if(handle == INVALID_HANDLE) return;
   FileSeek(handle, 0, SEEK_END);
   FileWrite(handle, TimeToString(TimeCurrent(),TIME_DATE|TIME_SECONDS), context, msg);
   FileClose(handle);
}

//--- Gestion logs erreurs
void LogError(string context, string msg) {
   int handle = FileOpen("EA_ERRORS.csv", FILE_WRITE|FILE_CSV|FILE_ANSI);
   if(handle == INVALID_HANDLE) return;
   FileSeek(handle, 0, SEEK_END);
   FileWrite(handle, TimeToString(TimeCurrent(),TIME_DATE|TIME_SECONDS), context, msg);
   FileClose(handle);
}

//--- Safe sleep (robustesse)
void SafeSleep(int ms) {
   ulong end = GetTickCount() + ms;
   while(GetTickCount() < end) {
      if(IsStopped()) break;
      Sleep(10);
   }
}

//--- OnDeinit complet
void OnDeinit(const int reason) { 
   Comment(""); 
   ObjectsDeleteAll(0, prefix+"_");
   ObjectsDeleteAll(0, "EA_STATS_");
   ObjectsDeleteAll(0, prefix+"_CLOSE_BTN");
   LogEvent("Deinit", "EA stopped or removed from chart.");
}

//--- Hooks d'extension et finalisation (voir partie suivante)

//--- HOOKS D’EXTENSION, CONSEILS, RÉSUMÉ, FIN DU CODE ---

//--- HOOK pour nouvelle stratégie (exemple, pour extension IA, grid, etc.)
/*
// bool DetectGridStrategySignal(TradeSignal &signal) { ... return false; }
   // Dans CheckTradingConditions() :
   // if(EnableGrid && DetectGridStrategySignal(sig)) { signal=sig; return true; }
*/

//--- HOOK pour logs avancés (ex : logs JSON, serveur web)
// void LogTradeAdvanced(...) { ... }

//--- HOOK signaux UI (affichage signaux détectés, etc.)
// void ShowPendingSignal(const TradeSignal &sig) { ... }

//--- Conseils d’utilisation et tuning longue durée
/*
- Pour le SCALPING : ajuste Scalping_ATR_Min et Scalping_Spread_Max selon la volatilité.
- Marchés rapides : augmente panelWidth et closeBtnSize.
- Multi-symboles : duplique la structure contextuelle pour chaque symbole.
- Pour logs pro : active EnableTradeLogging, vérifie les fichiers CSV générés.
- Pour usage institutionnel : ajoute hooks web ou notifications.
- En cas de crash : consulte EA_ERRORS.csv ou EA_EVENTS.csv.
- Pour la perf : évite >10 graphiques en simultané sur VPS standard.
- Pour le backtest : active toutes les stratégies, vérifie le spread par instrument.
*/






void OnTradeTransaction(const MqlTradeTransaction &trans, const MqlTradeRequest &request, const MqlTradeResult &result) {
   if (trans.type == TRADE_TRANSACTION_DEAL_ADD && (trans.deal_type == DEAL_TYPE_BUY || trans.deal_type == DEAL_TYPE_SELL)) {
      //UpdateTradeStats();   // met à jour immédiatement les stats
       UpdateDayStats();
       DrawStatsPanel();     // rafraîchit l'affichage du panneau
   }
}
//--- FIN DU CODE SBS TRADING DIAMOND V12.0 .mq5 ---