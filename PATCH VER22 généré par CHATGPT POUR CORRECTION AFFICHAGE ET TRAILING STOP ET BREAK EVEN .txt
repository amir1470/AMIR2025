// PATCH VER 22 par CHAT GPT pour l'affichage correct

//+------------------------------------------------------------------+
//|               SBS DIAMOND PRO Ver 22 - PATCH 2025                 |
//|          Implemented by Zied Bensaber with GPT-4.5                |
//|  Dashboard, trailing, partial closing, anomalies and much more   |
//+------------------------------------------------------------------+

// ----------------------------------------------------------------------------
// [1] Cacher toutes les annotations sur le graphe
// ----------------------------------------------------------------------------
void HideChartElements()
{
   ChartSetInteger(0, CHART_SHOW_TRADE_LEVELS, false);
   ChartSetInteger(0, CHART_SHOW_OBJECT_DESCRIPTIONS, false);
   ChartSetInteger(0, CHART_SHOW_MARKS, false);
   ChartSetInteger(0, CHART_SHOW_GRID, false);
   ChartSetInteger(0, CHART_MODE, CHART_CANDLES);
}

// ----------------------------------------------------------------------------
// [2] Declare color and style for Dashboard
// ----------------------------------------------------------------------------
#define COLOR_PANEL_BG  C'30,30,30'
#define COLOR_HEADER    clrDeepSkyBlue
#define COLOR_TEXT      clrWhite
#define COLOR_PROFIT    clrLime
#define COLOR_LOSS      clrRed
#define COLOR_WARNING   clrOrangeRed

// ----------------------------------------------------------------------------
// [ OnInit ]
// ----------------------------------------------------------------------------
int OnInit()
{
   // Cacher toutes annotations sur le graphe
   HideChartElements();

   // Vérification des paires autorisées
   string allowedSymbols[] = {"EURUSD", "USDJPY", "EURGBP", "USDGBP", "USDCAD",
                             "AUDCAD", "AUDUSD", "GBPUSD", "USDCHF", "XAUUSD", "GOLD", "BTCUSD"};
   bool symbolAllowed = false;

   for(int i = 0; i < ArraySize(allowedSymbols); i++) {
      if(_Symbol == allowedSymbols[i]) {
         symbolAllowed = true;
         break;
      }
   }

   if(!symbolAllowed) {
      Alert("EA DIAMOND v17.1 can't Trade this Pair/Symbol ", _Symbol);
      return(INIT_FAILED);
   }

   // Initialisation des variables
   InitGlobalVars();
   CheckGoldSymbol();

   // Initialisation des stratégies et des performances
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      strategyPerformance[i].strategy = (ENUM_STRATEGY)(i+1);
      strategyPerformance[i].enabled = true;
      strategyPerformance[i].weight = 1.0;
   }

   // Initialisation des indicateurs
   if(!strategyManager.InitializeIndicators()) {
      Print("Failed to initialize indicators!");
      return(INIT_FAILED);
   }

   // Vérification des handles
   if(!strategyManager.CheckIndicators()) {
      Print("Indicator check failed!");
      return(INIT_FAILED);
   }

   // Initialisation des strategies
   InitializeStrategies();

   // Chargement des performances depuis le Global
   LoadStrategyPerformance();

   // Démarrer le timer toutes les 10sec
   EventSetTimer(10);

   // Démarrer le tableau de bord
   UpdateDashboard();

   return(INIT_SUCCEEDED);
}

////////////// PARTIE 2 /////////////////
// ----------------------------------------------------------------------------
// [ Sortie Partielle et Trailing Stop ]
// ----------------------------------------------------------------------------

// Cette fonction est invoquée depuis CTradeManager::ManagePositions()
void CTradeManager::ManagePositions()
{
   for(int i = (int)PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic = (int)PositionGetInteger(POSITION_MAGIC);
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double tp = PositionGetDouble(POSITION_TP);
         double sl = PositionGetDouble(POSITION_SL);
         double volume = PositionGetDouble(POSITION_VOLUME);
         ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
         
         // Sortie Partielle +1R
         double stopDistance = MathAbs(entry - sl);
         double r = 0.0;

         if(type == POSITION_TYPE_BUY && stopDistance > 0)
            r = (SymbolInfoDouble(_Symbol, SYMBOL_BID) - entry) / stopDistance;
         else if(type == POSITION_TYPE_SELL && stopDistance > 0)
            r = (entry - SymbolInfoDouble(_Symbol, SYMBOL_ASK)) / stopDistance;

         if(volume >= 0.2 && r >= 1.0) { // +1R -> on prend 50%
            PartialClose(ticket, 0.5);
            Print("Sortie partielle 50% ", ticket);
         }

         // Trailing Stop + Break-even
         double atr = iATR(_Symbol, _Period, ATRPeriod);
         double profit = PositionGetDouble(POSITION_PROFIT);

         if(type == POSITION_TYPE_BUY && profit > atr * 100) {
            double newSL = SymbolInfoDouble(_Symbol, SYMBOL_BID) - atr * 1.0;
            if(newSL > sl) trade.PositionModify(ticket, newSL, tp);
         }
         if(type == POSITION_TYPE_SELL && profit > atr * 100) {
            double newSL = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + atr * 1.0;
            if(newSL < sl) trade.PositionModify(ticket, newSL, tp);
         }
         
         // Break-even
         if(type == POSITION_TYPE_BUY && SymbolInfoDouble(_Symbol, SYMBOL_BID)-entry > atr*1.5 && sl < entry) {
            trade.PositionModify(ticket, entry, tp);
            Print("Break-even activé.", ticket);
         }
         if(type == POSITION_TYPE_SELL && entry-SymbolInfoDouble(_Symbol, SYMBOL_ASK) > atr*1.5 && sl > entry) {
            trade.PositionModify(ticket, entry, tp);
            Print("Break-even activé.", ticket);
         }
      }
   }
}

// ----------------------------------------------------------------------------
// [ Fermeture globale en cas d'anomalie ou profits/loss ]
// ----------------------------------------------------------------------------
void CheckIntelligentExit()
{
   double totalProfit = 0.0;
   int openPositions = 0;

   int total = PositionsTotal();

   for(int i = 0; i < total; i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);
         if((pos_symbol == _Symbol) && (pos_magic == MagicNumber)) {
            totalProfit += PositionGetDouble(POSITION_PROFIT);
            openPositions++;
         }
      }
   }

   // Seuils de fermeture globale
   double profitThreshold = 50.0;
   double lossThreshold   = -30.0;

   bool anomaly = DetectMarketAnomaly();

   if(openPositions > 0) {
      if(totalProfit >= profitThreshold ||
         totalProfit <= lossThreshold ||
         anomaly) {
         Print("Full close triggered: total profit=", totalProfit, ", anomaly=", anomaly);
         PerformFullClose();
      }
   }
}

// ----------------------------------------------------------------------------
// [ Performances et Détails ]
// ----------------------------------------------------------------------------
double CalculateMaxDrawdown()
{
   double maxEquity = AccountInfoDouble(ACCOUNT_BALANCE);
   double minEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double dd = maxEquity - minEquity;

   return dd;
}

void PerformFullClose()
{
   int total = PositionsTotal();
   for(int i = total - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);
         
         if((pos_symbol == _Symbol) &&
            (pos_magic == MagicNumber)) 
         {
            trade.PositionClose(ticket);
            Print("Close all for ", ticket);
         }
      }
   }
}

// ----------------------------------------------------------------------------
// [ Anomalie de Marché ]
// ----------------------------------------------------------------------------
bool DetectMarketAnomaly()
{
   double spread = (SymbolInfoInteger(_Symbol, SYMBOL_SPREAD)) * _Point;

   if(spread > 10 * _Point) // 1 pip ou plus de 10 points
      return(true);

   // Detecter d’autres anomalies...
   return(false);
}


///////////// PARTIE 3 ///////////////////////
// ----------------------------------------------------------------------------
// [ Dashboard Professionnel ]
// ----------------------------------------------------------------------------
void UpdateDashboard()
{
   DeleteDashboard();

   // Panneau principal
   ObjectCreate(0,"DASHBOARD_PANEL",OBJ_RECTANGLE_LABEL,0,0,0);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_XDISTANCE,DashboardPosX);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_YDISTANCE,DashboardPosY);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_XSIZE,DashboardWidth);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_YSIZE,DashboardHeight);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_CORNER,0);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_COLOR,COLOR_PANEL_BG);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_BACK,true);
   ObjectSetInteger(0,"DASHBOARD_PANEL",OBJPROP_SELECTABLE,false);

   int y = DashboardPosY + 20;

   // Titre
   ObjectCreate(0,"DASHBOARD_HEADER",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"DASHBOARD_HEADER",OBJPROP_XDISTANCE,DashboardPosX + 20);
   ObjectSetInteger(0,"DASHBOARD_HEADER",OBJPROP_YDISTANCE,y);
   ObjectSetInteger(0,"DASHBOARD_HEADER",OBJPROP_COLOR,COLOR_HEADER);
   ObjectSetInteger(0,"DASHBOARD_HEADER",OBJPROP_FONTSIZE,14);
   ObjectSetString(0,"DASHBOARD_HEADER",OBJPROP_TEXT,"★ SBS DIAMOND PRO Ver 22 ★");

   y += 30;

   // Pair, TF, Spread, EA actif
   int fontSize = 10;

   double spread = (SymbolInfoInteger(_Symbol, SYMBOL_SPREAD)) * _Point;

   bool isPause = TimeCurrent() < riskManager.PauseUntil();

   string infoPair = "Pair : " + _Symbol + " | TF : " + EnumToString(_Period) + " | Spread : " + DoubleToString(spread / _Point, 1) + " pips | EA : " + (isPause ? "PAUSE" : "ACTIF");

   ObjectCreate(0,"DASHBOARD_PAIR",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"DASHBOARD_PAIR",OBJPROP_XDISTANCE,DashboardPosX + 20);
   ObjectSetInteger(0,"DASHBOARD_PAIR",OBJPROP_YDISTANCE,y);
   ObjectSetInteger(0,"DASHBOARD_PAIR",OBJPROP_COLOR,clrWhite);
   ObjectSetInteger(0,"DASHBOARD_PAIR",OBJPROP_FONTSIZE,fontSize);
   ObjectSetString(0,"DASHBOARD_PAIR",OBJPROP_TEXT,infoPair);

   y += 20;

   // Compte
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   int totalTrades = 0, tradesWin = 0, tradesLoss = 0;

   for(int i = 0; i < HistoryDealsTotal(); i++) {
      ulong ticket = HistoryDealGetTicket(i);
      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
      if(profit > 0) tradesWin++;
      else if(profit < 0) tradesLoss++;
      totalTrades++;
   }

   string account = 
      "Balance : " + DoubleToString(balance, 2) + 
      " | Equity : " + DoubleToString(equity, 2) + 
      " | Profits : " + DoubleToString(AccountInfoDouble(ACCOUNT_PROFIT), 2) + 
      " | Gagnants : " + IntegerToString(tradesWin) + 
      " | Perdants : " + IntegerToString(tradesLoss) + 
      " | Max Drawdown : " + DoubleToString(CalculateMaxDrawdown(), 2);

   ObjectCreate(0,"DASHBOARD_ACCOUNT",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"DASHBOARD_ACCOUNT",OBJPROP_XDISTANCE,DashboardPosX + 20);
   ObjectSetInteger(0,"DASHBOARD_ACCOUNT",OBJPROP_YDISTANCE,y);
   ObjectSetInteger(0,"DASHBOARD_ACCOUNT",OBJPROP_COLOR,clrWhite);
   ObjectSetInteger(0,"DASHBOARD_ACCOUNT",OBJPROP_FONTSIZE,fontSize);
   ObjectSetString(0,"DASHBOARD_ACCOUNT",OBJPROP_TEXT,account);

   y += 20;

   // Liste des stratégies
   for(int i = 0; i < strategies_total; i++) {
      StrategyStats s = strategies[i];
      string str = "→ " + s.Name + 
                   " | Gagnants : " + IntegerToString(s.Wins) + 
                   " | Perdants : " + IntegerToString(s.Losses) + 
                   " | Profit : " + FormatSigned(s.Profit, 2) + 
                   " | WinRate : " + DoubleToString(s.WinRate, 1) + "%";

      ObjectCreate(0,"DASHBOARD_STRAT_" + IntegerToString(i),OBJ_LABEL,0,0,0);
      ObjectSetInteger(0,"DASHBOARD_STRAT_" + IntegerToString(i),OBJPROP_XDISTANCE,DashboardPosX + 20);
      ObjectSetInteger(0,"DASHBOARD_STRAT_" + IntegerToString(i),OBJPROP_YDISTANCE,y);
      ObjectSetInteger(0,"DASHBOARD_STRAT_" + IntegerToString(i),OBJPROP_COLOR,s.StatusColor);
      ObjectSetInteger(0,"DASHBOARD_STRAT_" + IntegerToString(i),OBJPROP_FONTSIZE,fontSize);
      ObjectSetString(0,"DASHBOARD_STRAT_" + IntegerToString(i),OBJPROP_TEXT,str);

      y += 20;
   }

   // Bouton Fermeture
   ObjectCreate(0,"DASHBOARD_CLOSE",OBJ_RECTANGLE_LABEL,0,0,0);
   ObjectSetInteger(0,"DASHBOARD_CLOSE",OBJPROP_XDISTANCE,DashboardPosX + DashboardWidth - 38);
   ObjectSetInteger(0,"DASHBOARD_CLOSE",OBJPROP_YDISTANCE,DashboardPosY + 8);
   ObjectSetInteger(0,"DASHBOARD_CLOSE",OBJPROP_XSIZE,30);
   ObjectSetInteger(0,"DASHBOARD_CLOSE",OBJPROP_YSIZE,22);
   ObjectSetInteger(0,"DASHBOARD_CLOSE",OBJPROP_COLOR,C'255,60,60'); // rouge
   ObjectSetInteger(0,"DASHBOARD_CLOSE",OBJPROP_BACK,false);

   ObjectCreate(0,"DASHBOARD_CLOSE_TXT",OBJ_LABEL,0,0,0);
   ObjectSetInteger(0,"DASHBOARD_CLOSE_TXT",OBJPROP_XDISTANCE,DashboardPosX + DashboardWidth - 33);
   ObjectSetInteger(0,"DASHBOARD_CLOSE_TXT",OBJPROP_YDISTANCE,DashboardPosY + 12);
   ObjectSetInteger(0,"DASHBOARD_CLOSE_TXT",OBJPROP_COLOR,clrWhite);
   ObjectSetInteger(0,"DASHBOARD_CLOSE_TXT",OBJPROP_FONTSIZE,fontSize);
   ObjectSetString(0,"DASHBOARD_CLOSE_TXT",OBJPROP_TEXT,"X");

}

void DeleteDashboard()
{
   ObjectDelete(0,"DASHBOARD_PANEL");

   ObjectDelete(0,"DASHBOARD_HEADER");

   ObjectDelete(0,"DASHBOARD_PAIR");

   ObjectDelete(0,"DASHBOARD_ACCOUNT");

   for(int i = 0; i < strategies_total; i++) {
      ObjectDelete(0,"DASHBOARD_STRAT_" + IntegerToString(i));   
   }

   ObjectDelete(0,"DASHBOARD_CLOSE");

   ObjectDelete(0,"DASHBOARD_CLOSE_TXT");

}

void OnChartEvent(const int id,
                   const long &lparam,
                   const double &dparam,
                   const string &sparam)
{
   if(id == CHARTEVENT_OBJECT_CLICK)
   {
      if(sparam == "DASHBOARD_CLOSE")
      {
         ExpertRemove();
      }
   }
}

////////////////// PARTIE 4 /////////////////////

// ----------------------------------------------------------------------------
// [ Rapport des trades ]
// ----------------------------------------------------------------------------
void GenerateTradeReport()
{
   string fileName = "Trade_report.csv";

   int handle = FileOpen(fileName,FILE_WRITE|FILE_CSV);
   if(handle == INVALID_HANDLE)
   {
      Print("Impossible d'ouvrir le rapport.");
      return;
   }

   FileWrite(handle,"Ticket;Symbol;Type;Volume;OpenPrice;ClosePrice;Profit");

   for(int i = 0; i < HistoryDealsTotal(); i++) {
      ulong ticket = HistoryDealGetTicket(i);
      string symbol = HistoryDealGetString(ticket, DEAL_SYMBOL);
      int    type   = (int)HistoryDealGetInteger(ticket, DEAL_TYPE);
      double volume = HistoryDealGetDouble(ticket, DEAL_VOLUME);
      double priceOpen = HistoryDealGetDouble(ticket, DEAL_ENTRY_PRICE);
      double priceClose = HistoryDealGetDouble(ticket, DEAL_PRICE);
      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);

      FileWrite(handle,
                 IntegerToString(ticket) + ";" + 
                 symbol + ";" + 
                 (type == DEAL_TYPE_BUY ? "Buy" : "Sell") + ";" + 
                 DoubleToString(volume, 2) + ";" + 
                 DoubleToString(priceOpen, 5) + ";" + 
                 DoubleToString(priceClose, 5) + ";" + 
                 DoubleToString(profit, 2));

   }
   FileClose(handle);
   Print("Rapport généré :", fileName);
}

// ----------------------------------------------------------------------------
// [ Correction et finalisation ]
// ----------------------------------------------------------------------------

// Appeler dans OnDeinit()
void OnDeinit(const int reason)
{
   // Save strategy performance data
   SaveStrategyPerformance();

   // Génération rapport CSV
   GenerateTradeReport();

   // Delete Dashboard
   DeleteDashboard();

   // Arrêter le timer
   EventKillTimer();

   // Fermeture de l'EA
   Print("EA arrêté.");

}






