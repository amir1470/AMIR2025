//+------------------------------------------------------------------+
//|                     DIAMOND EA VER30 - CORRECTED                 |
//|                  Multi-strategy Expert Advisor                   |
//|                 Compatible avec GOLD (Gold/XAUUSD)               |
//|                 Auteur: amirbs14 - github.com/amirbs14           |
//|                 Version corrigée et optimisée                    |
//+------------------------------------------------------------------+

//========================================================================
// SECTION 1 : INCLUDES ET CONFIGURATION DE BASE
//========================================================================
#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Indicators\Trend.mqh>
#include <Indicators\Oscilators.mqh>
#include <Indicators\Volumes.mqh>
#include <Generic\ArrayList.mqh>
#include <Arrays\ArrayObj.mqh>
#include <Generic\HashMap.mqh>
#include <ChartObjects\ChartObjectsTxtControls.mqh>
#include <ChartObjects\ChartObjectsShapes.mqh>
#include <Generic\HashSet.mqh>

#define MinLotsAllowed InitialLot
#define MaxLotsAllowed MaxLot
#define MaxPositionsPerSymbol 5  // ou la valeur que vous souhaitez


//--- Définition des propriétés de l'EA
#property copyright "amirbs14"
#property link      "https://github.com/amirbs14"
#property version   "30.0"
#property strict

//========================================================================
// SECTION 2 : ENUMERATIONS ET STRUCTURES
//========================================================================
/// Énumération complète des stratégies utilisées dans tout l'EA
/// STRATEGY_COUNT doit toujours rester la dernière entrée
enum ENUM_STRATEGY
{
    STRAT_CHECKLIST = 0,
    STRAT_BREAKOUT_RANGE,
    STRAT_PULLBACK_EMA,
    STRAT_SUPERTREND,
    STRAT_RETEST_SR,
    STRAT_SCALPING,
    STRATEGY_COUNT
};

#define MAX_SYMBOLS 20

//+------------------------------------------------------------------+
//| Structure pour les performances des stratégies                   |
//+------------------------------------------------------------------+
struct SStrategyPerformance {
   ENUM_STRATEGY strategy;     // Type de stratégie
   int totalTrades;            // Nombre total de trades
   int wins;                   // Trades gagnants
   int losses;                 // Trades perdants
   double totalProfit;         // Profit total
   double winRate;             // Taux de réussite
   double profitFactor;        // Facteur de profit
   bool enabled;               // Statut d'activation
   datetime lastTradeTime;     // Heure du dernier trade
   double weight;              // Poids dans la sélection
};

//+------------------------------------------------------------------+
//| Structure pour les signaux de trading                           |
//+------------------------------------------------------------------+
struct STradeSignal {
   bool valid;                 // Validité du signal
   bool isBuySignal;           // Signal d'achat si vrai
   double price;               // Prix d'entrée
   double sl;                  // Niveau de stop-loss
   double tp;                  // Niveau de take-profit
   ENUM_STRATEGY strategy;     // Stratégie générant le signal
   string comment;             // Commentaire descriptif
};

//+------------------------------------------------------------------+
//| Structure pour les statistiques par symbole                      |
//+------------------------------------------------------------------+
struct SSymbolStats {
   string symbol;              // Symbole du marché
   int totalTrades;            // Trades totaux
   int winTrades;              // Trades gagnants
   int lossTrades;             // Trades perdants
   int todayTrades;            // Trades aujourd'hui
   int todayWins;              // Gains aujourd'hui
   int todayLosses;            // Pertes aujourd'hui
   double spreadSum;           // Somme des spreads
   int spreadCount;            // Nombre de spreads enregistrés
   double spreadMax;           // Spread maximum observé
   double lastSpread;          // Dernier spread enregistré
};

//+------------------------------------------------------------------+
//| Structure pour les statistiques des stratégies                   |
//+------------------------------------------------------------------+
struct StrategyStats {
   string  Name;               // Nom de la stratégie
   bool    Enabled;            // Statut d'activation
   int     TotalTrades;        // Trades totaux
   int     Wins;               // Trades gagnants
   int     Losses;             // Trades perdants
   double  Profit;             // Profit total
   double  WinRate;            // Taux de réussite
   color   StatusColor;        // Couleur d'affichage
};

//+------------------------------------------------------------------+
//| Structure pour les statistiques quotidiennes                     |
//+------------------------------------------------------------------+
struct DailyStats {
   datetime Day;               // Date
   double   Profit;            // Profit du jour
   int      Trades;            // Nombre de trades
   double   MaxDrawdown;       // Drawdown maximum
};

//========================================================================
// SECTION 3 : PARAMETRES D'ENTREE
//========================================================================
input int MinStrategyConfirmations = 3; // ✅ Nombre minimal de stratégies pour autoriser un trade

input group "Risk Management"
input double   MaxDailyLossPercent = 5.0;    // Perte quotidienne max (% du balance)
input double   MaxLossPercent = 2.0;         // Perte max par trade (% du balance)
input int      MaxConsecutiveLosses = 10;    // Pertes consécutives max avant pause
input int      PauseAfterLosses = 10;        // Pause après X pertes consécutives
input int      PauseDurationMinutes = 30;    // Durée de pause en minutes
input int      MinMinutesBetweenTrades = 5;  // Temps minimum entre trades
input bool     EnableStrategyAutoManagement = true; // Gestion automatique des stratégies
input bool     EnableNotifications = true;   // Activer les notifications
input bool     EnableDebugLog = true;        // Activer les logs détaillés

input group "SuperTrend Settings"
input int      SuperTrend_ATRPeriod = 10;    // Période ATR pour SuperTrend
input double   SuperTrend_Multiplier = 3.0;  // Multiplicateur pour SuperTrend
input bool     EnableSuperTrendInput = true; // Activer la stratégie SuperTrend

input group "Checklist Strategy Parameters"
input int      Checklist_MACD_Fast = 8;      // Période rapide MACD
input int      Checklist_MACD_Slow = 20;     // Période lente MACD
input int      Checklist_MACD_Signal = 9;    // Période signal MACD
input double   Checklist_RSI_Min = 30.0;     // Niveau minimum RSI
input double   Checklist_RSI_Max = 70.0;     // Niveau maximum RSI
input double   Checklist_ADX_Min = 10.0;     // Niveau minimum ADX

input group "Additional Parameters"
input int      MinTradesToDisable = 20;      // Trades min avant désactivation
input double   MinWinRateToDisable = 40.0;   // Taux de réussite min (%)
input int      ReEnableAfterHours = 24;      // Heures avant réactivation
input double   MaxSpreadPips = 30.0;         // Tolérance max du spread en pips

input group "Trading Settings"
input double   RiskPercent = 0.5;            // Pourcentage de risque
input double   InitialLot = 0.01;            // Taille de lot initiale
input double   MaxLot = 0.5;                 // Taille de lot maximum
input int      MagicNumber = 20200520;       // Magic number unique
input int      Slippage = 1;                 // Slippage max (points)
input int      ATRPeriod = 14;               // Période ATR pour filtre volatilité

input group "Dashboard Settings"
input int      DashboardPosX = 10;           // Position X du dashboard (pixels)
input int      DashboardPosY = 10;           // Position Y du dashboard (pixels)
input int      DashboardWidth = 420;         // Largeur du dashboard (pixels)
input int      DashboardHeight = 220;        // Hauteur du dashboard (pixels)
input bool     EnableSound = true;           // Activer les alertes sonores

//========================================================================
// SECTION 4 : VARIABLES GLOBALES
//========================================================================
datetime lastOptimization = 0;
double          g_LastEquity      = 0.0;     // Dernière valeur d'equity
double          g_LastBalance     = 0.0;     // Dernière valeur de balance
double          g_ATRValue        = 0.0;     // Valeur ATR courante
string          g_SymbolGold1     = "GOLD";  // Premier symbole pour l'or
string          g_SymbolGold2     = "XAUUSDm";// Deuxième symbole pour l'or
bool            g_IsGold          = false;   // Si le symbole courant est l'or
bool            ea_is_active      = true;    // Statut d'activation de l'EA
bool            EnableSuperTrend  = true;    // Statut d'activation SuperTrend

// Tableaux pour le suivi des performances
StrategyStats strategies[];
int strategies_total = 0;
DailyStats day_stats[];

// Handles et objets globaux
CTrade trade;                               // Objet pour exécuter les trades
CPositionInfo positionInfo;                 // Information sur les positions
CHistoryOrderInfo historyOrder;             // Information historique
CDealInfo dealInfo;                         // Information sur les deals
int macdHandle;                             // Handle MACD
int rsiHandle;                              // Handle RSI

// Suivi du temps
datetime lastPerformanceSaveTime = 0;       // Dernière sauvegarde
const int PERFORMANCE_SAVE_INTERVAL = 3600; // Intervalle de sauvegarde (sec)

// Performances des stratégies
SStrategyPerformance strategyPerformance[STRATEGY_COUNT];
SSymbolStats stats[MAX_SYMBOLS];
int symbolCount = 0;

// Suivi des trades
datetime lastTradeTime = 0;                 // Heure du dernier trade
ulong lastTradeTicket = 0;                  // Ticket du dernier trade

//========================================================================
// SECTION 5 : CLASSES PRINCIPALES
//========================================================================

//+------------------------------------------------------------------+
//| Classe CRiskManager - Gestion avancée des risques               |
//+------------------------------------------------------------------+
class CRiskManager
{
private:
   double   maxDailyLossPercent;      // Perte quotidienne max (%)
   double   maxLossPercent;           // Perte max par trade (%)
   int      maxConsecutiveLosses;     // Pertes consécutives max
   int      pauseAfterLosses;         // Déclenche la pause après X pertes
   int      pauseDurationMinutes;     // Durée de pause (minutes)

   int      consecutiveLosses;        // Compteur de pertes consécutives
   datetime pauseUntil;               // Horodatage de reprise
   datetime lastTradeTime;            // Horodatage du dernier trade

public:
   //--- Constructeur -------------------------------------------------
   CRiskManager(double dailyLossPct,
                double lossPct,
                int    maxConsLoss,
                int    pauseLoss,
                int    pauseMin) :
     maxDailyLossPercent(dailyLossPct),
     maxLossPercent(lossPct),
     maxConsecutiveLosses(maxConsLoss),
     pauseAfterLosses(pauseLoss),
     pauseDurationMinutes(pauseMin),
     consecutiveLosses(0),
     pauseUntil(0),
     lastTradeTime(0)
   { }

   //--- Le trading est-il autorisé ? ---------------------------------
   bool IsTradeAllowed() const
     {
      // Pause active ?
      if(TimeCurrent() < pauseUntil)
         return(false);

      // Drawdown quotidien (balance – equity)
      double balance     = AccountInfoDouble(ACCOUNT_BALANCE);
      double equity      = AccountInfoDouble(ACCOUNT_EQUITY);
      double dailyLossPc = (balance == 0.0) ? 0.0
                           : ((balance - equity) / balance) * 100.0;

      if(dailyLossPc >= maxDailyLossPercent)
         return(false);

      return true;
     }

   //--- Mise à jour après chaque trade -------------------------------
   void UpdateTradeResult(double profit)
     {
      if(profit < 0.0)
        {
         consecutiveLosses++;

         if(consecutiveLosses >= maxConsecutiveLosses)
           {
            // Mise en pause
            pauseUntil       = TimeCurrent() + pauseDurationMinutes * 60;
            consecutiveLosses = 0;                         // on reset
           }
        }
      else
         consecutiveLosses = 0;                            // gain => reset

      lastTradeTime = TimeCurrent();
     }

   //--- Taille de position (approche % de balance) -------------------
   double CalculatePositionSize(double entry, double stopLoss) const
     {
      if(stopLoss == 0.0 || entry == 0.0)
         return 0.0;

      double stopDistance = MathAbs(entry - stopLoss);
      if(stopDistance <= 0.0)
         return 0.0;

      // Montant risqué
      double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) *
                          maxLossPercent / 100.0;

      // Valeurs symboles
      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize  = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double lotStep   = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      double minLot    = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double maxLot    = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

      double costPerLot = (stopDistance / tickSize) * tickValue;
      if(costPerLot <= 0.0)
         return 0.0;

      double rawLots     = riskAmount / costPerLot;
      double roundedLots = MathFloor(rawLots / lotStep) * lotStep;

      // Bornes broker
      return MathMax(minLot, MathMin(roundedLots, maxLot));
     }

   //--- Compte les positions ouvertes pour un symbole ----------------
   int GetOpenPositionsCount(const string symbol) const
     {
      int posCount = 0;
      int posTotal = PositionsTotal();

      for(int idx = posTotal - 1; idx >= 0; idx--)
        {
         ulong posTicket = PositionGetTicket(idx);
         if(posTicket == 0)
            continue;

         if(PositionSelectByTicket(posTicket) &&
            PositionGetString(POSITION_SYMBOL) == symbol)
               posCount++;
        }
      return posCount;
     }

   //--- Vérifie le délai minimum entre deux trades -------------------
   bool CheckMinTimeBetweenTrades(int minMinutes) const
     {
      return (TimeCurrent() - lastTradeTime) >= (minMinutes * 60);
     }

   //--- Reset manuel des pertes consécutives -------------------------
   void ResetConsecutiveLosses()
     {
      consecutiveLosses = 0;
      pauseUntil        = 0;
     }
};

//+------------------------------------------------------------------+
//| Classe CTradeManager - Gestion des opérations de trading        |
//+------------------------------------------------------------------+
class CTradeManager {
private:
   CRiskManager *riskManager;
   CTrade trade;
   double minLotsAllowed;
   double maxLotsAllowed;
   int maxPositionsPerSymbol;
   int magicNumber;
   int slippage;
   int atrPeriod;
   bool enableNotifications;
   bool enableSound;
   int minMinutesBetweenTrades;

public:
   CTradeManager(CRiskManager *manager, 
                double _minLots, 
                double _maxLots, 
                int _maxPositions,
                int _magic,
                int _slippage,
                int _atrPeriod,
                bool _enableNotif,
                bool _enableSound,
                int _minMinutes) : riskManager(manager) {
      minLotsAllowed = _minLots;
      maxLotsAllowed = _maxLots;
      maxPositionsPerSymbol = _maxPositions;
      magicNumber = _magic;
      slippage = _slippage;
      atrPeriod = _atrPeriod;
      enableNotifications = _enableNotif;
      enableSound = _enableSound;
      minMinutesBetweenTrades = _minMinutes;
      
      trade.SetExpertMagicNumber(magicNumber);
      trade.SetMarginMode();
      trade.SetTypeFillingBySymbol(_Symbol);
      trade.SetDeviationInPoints(slippage);
   }
   
   // Gère les stops des positions ouvertes
   void ManageStops() {
      for(int i = PositionsTotal()-1; i >= 0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket)) {
            string pos_symbol = PositionGetString(POSITION_SYMBOL);
            int pos_magic = (int)PositionGetInteger(POSITION_MAGIC);
            
            if(pos_symbol == _Symbol && pos_magic == MagicNumber) {
               ManageTrailingStop(ticket, 
                  (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE),
                  PositionGetDouble(POSITION_PRICE_OPEN),
                  PositionGetDouble(POSITION_SL),
                  PositionGetDouble(POSITION_TP));
            }
         }
      }
   }
   
   // Exécute un trade basé sur un signal
   bool ExecuteTrade(const STradeSignal &signal) {
      if(!signal.valid || !CanOpenNewPosition(_Symbol)) {
         Print("Impossible d'exécuter le trade - signal invalide ou positions max atteintes");
         return false;
      }

      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double market_price = signal.isBuySignal ? ask : bid;

      double lots = riskManager.CalculatePositionSize(signal.price, signal.sl);
      lots = MathMax(minLotsAllowed, MathMin(maxLotsAllowed, lots));
      if(lots <= 0) {
         Print("Taille de lot calculée invalide: ", lots);
         return false;
      }

      if(signal.sl <= 0 || signal.tp <= 0) {
         Print("SL ou TP invalides: SL=", signal.sl, " TP=", signal.tp);
         return false;
      }

      if(!ValidatePrices(market_price, signal.sl, signal.tp, signal.isBuySignal)) {
         Print("SL/TP invalides pour le prix actuel");
         return false;
      }

      PrintFormat("\xF0\x9F\x93\x8C Signal reçu : %s | Lots=%.2f | Prix=%.2f | SL=%.2f | TP=%.2f",
                  signal.isBuySignal ? "BUY" : "SELL",
                  lots, signal.price, signal.sl, signal.tp);

      // Envoi sans SL/TP initial pour contourner l'erreur 4753
      bool result = signal.isBuySignal ?
                    trade.Buy(lots, _Symbol, 0, 0, 0, signal.comment) :
                    trade.Sell(lots, _Symbol, 0, 0, 0, signal.comment);

      if(result) {
         ulong deal_ticket = trade.ResultDeal();
         double profit = 0.0;
         if(deal_ticket > 0) {
            profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
         }

         // Ajout SL/TP après ouverture
         if(!trade.PositionModify(_Symbol, signal.sl, signal.tp)) {
            Print("⚠️ Échec de l'ajout SL/TP après ouverture : ", trade.ResultRetcodeDescription());
         } else {
            PrintFormat("✅ SL/TP appliqués après ouverture : SL=%.5f | TP=%.5f", signal.sl, signal.tp);
         }

         riskManager.UpdateTradeResult(profit);

         if(enableNotifications) {
            string msg = StringFormat("New %s trade opened via %s. Lots: %.2f SL: %.5f TP: %.5f",
                                      signal.isBuySignal ? "BUY" : "SELL",
                                      EnumToString(signal.strategy),
                                      lots, signal.sl, signal.tp);
            Alert(_Symbol + " " + EnumToString(_Period) + ": " + msg);
            if(enableSound) PlaySound("alert.wav");
         }
         return true;
      }

      Print("Échec de l'exécution du trade. Erreur: ", GetLastError());
      return false;
   }

   // Gère les positions ouvertes
   void ManagePositions() {
      for(int i = (int)PositionsTotal() - 1; i >= 0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket)) {
            string pos_symbol = PositionGetString(POSITION_SYMBOL);
            int pos_magic = (int)PositionGetInteger(POSITION_MAGIC);

            if(pos_symbol != _Symbol || pos_magic != magicNumber) continue;

            double entry = PositionGetDouble(POSITION_PRICE_OPEN);
            double tp = PositionGetDouble(POSITION_TP);
            double sl = PositionGetDouble(POSITION_SL);
            double volume = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

            ManagePartialClose(ticket, type, entry, sl, volume);
            ManageTrailingStop(ticket, type, entry, sl, tp);
         }
      }
   }

   // Vérifie si une nouvelle position peut être ouverte
   bool CanOpenNewPosition(string symbol) {
      if(PositionsCountBySymbol(symbol) >= maxPositionsPerSymbol) {
         Print("Max positions (", maxPositionsPerSymbol, ") atteint pour ", symbol);
         return false;
      }

      if(!riskManager.CheckMinTimeBetweenTrades(minMinutesBetweenTrades)) {
         Print("Temps minimum entre les trades non atteint");
         return false;
      }

      return CheckSpreadConditions(symbol);
   }

   // Ferme toutes les positions
   void CloseAllPositions() {
      for(int i = PositionsTotal()-1; i >= 0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket)) {
            string pos_symbol = PositionGetString(POSITION_SYMBOL);
            if(pos_symbol == _Symbol) {
               trade.PositionClose(ticket);
            }
         }
      }
   }

private:
   // Gère la fermeture partielle
   void ManagePartialClose(ulong ticket, ENUM_POSITION_TYPE type, double entry, double sl, double volume) {
      if(volume < 0.2) return;

      double stopDistance = MathAbs(entry - sl);
      if(stopDistance <= 0) return;

      double currentPrice = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) :
                                                          SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      double r = (type == POSITION_TYPE_BUY) ? (currentPrice - entry) / stopDistance :
                                               (entry - currentPrice) / stopDistance;

      if(r >= 1.0) {
         PartialClose(ticket, 0.5);
      }
   }

   // Gère le trailing stop
   void ManageTrailingStop(ulong ticket, ENUM_POSITION_TYPE type, double entry, double &sl, double tp) {
      double atr = iATR(_Symbol, _Period, atrPeriod);
      double profit = PositionGetDouble(POSITION_PROFIT);

      if(profit > atr * 100) {
         double newSL = 0;
         if(type == POSITION_TYPE_BUY) {
            newSL = SymbolInfoDouble(_Symbol, SYMBOL_BID) - atr;
            if(newSL > sl && newSL > entry) {
               trade.PositionModify(ticket, newSL, tp);
            }
         } else {
            newSL = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + atr;
            if(newSL < sl && newSL < entry) {
               trade.PositionModify(ticket, newSL, tp);
            }
         }
      }
   }

   // Ferme partiellement une position
   void PartialClose(ulong ticket, double percentage) {
      if(PositionSelectByTicket(ticket)) {
         double vol = PositionGetDouble(POSITION_VOLUME);
         double closeLots = MathMax(SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN), vol * percentage);
         if(closeLots > 0) {
            trade.PositionClosePartial(ticket, closeLots);
         }
      }
   }

   // Vérifie les conditions de spread
   bool CheckSpreadConditions(string symbol) {
      double spread = (double)SymbolInfoInteger(symbol, SYMBOL_SPREAD);
      double point = SymbolInfoDouble(symbol, SYMBOL_POINT);
      double spread_pips = spread * point / GetPipSize(symbol);
      
      double max_spread_pips = GetDynamicSpreadThreshold(symbol);
      
      if(spread_pips > max_spread_pips) {
         PrintFormat("⛔ Blocage du trade : spread %.2f > %.2f pips (seuil dynamique)", 
                  spread_pips, max_spread_pips);
         return false;
      }
      
      PrintFormat("[SPREAD CHECK] %s - Spread: %.2f pips | Seuil: %.2f pips | Statut: %s",
               symbol, spread_pips, max_spread_pips, 
               (spread_pips <= max_spread_pips) ? "OK" : "Trop élevé");
               
      return (spread_pips <= max_spread_pips);
   }
   
   // Vérifie si les prix SL/TP sont valides pour un trade
   bool ValidatePrices(double entry_price, double stop_loss, double take_profit, bool isBuy) {
      long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double min_distance = stops_level * _Point;
      if (min_distance < _Point) min_distance = 2 * _Point; // sécurité

      if (isBuy) {
         if (stop_loss >= entry_price || take_profit <= entry_price) return false;
         if ((entry_price - stop_loss) < min_distance || (take_profit - entry_price) < min_distance) return false;
      }
      else {
         if (stop_loss <= entry_price || take_profit >= entry_price) return false;
         if ((stop_loss - entry_price) < min_distance || (entry_price - take_profit) < min_distance) return false;
      }
      return true;
   }
   
   // Calcule la taille d'un pip pour le symbole
   double GetPipSize(string symbol) {
      int digits = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);
      if(StringFind(symbol, "XAUUSD") >= 0 || StringFind(symbol, "GOLD") >= 0) {
         return (digits == 2) ? 0.01 : 0.1;
      } else if(StringFind(symbol, "JPY") >= 0) {
         return 0.01;
      }
      return 0.0001;
   }
   
   // Calcule un seuil de spread dynamique
   double GetDynamicSpreadThreshold(string symbol) {
      double atr = iATR(symbol, _Period, 14);
      double pipSize = GetPipSize(symbol);
      double atr_pips = atr / pipSize;
      
      // Paramètres par défaut selon le type de symbole
      double min_spread = 2.0;
      double max_spread = 5.0;
      double atr_multiplier = 0.7;
      
      if(StringFind(symbol, "XAUUSD") >= 0 || StringFind(symbol, "GOLD") >= 0) {
         min_spread = 30.0;
         max_spread = 80.0;
         atr_multiplier = 0.5;
      } else if(StringFind(symbol, "JPY") >= 0) {
         min_spread = 1.5;
         max_spread = 3.5;
         atr_multiplier = 0.8;
      }
      
      return MathMax(min_spread, MathMin(atr_pips * atr_multiplier, max_spread));
   }
   
   // Compte les positions ouvertes pour un symbole
   int PositionsCountBySymbol(const string symbol) {
      int posCount = 0;
      int posTotal = PositionsTotal();
      for(int posIdx = posTotal - 1; posIdx >= 0; posIdx--) {
         ulong posTicket = PositionGetTicket(posIdx);
         if(posTicket == 0)
            continue;
         if(PositionSelectByTicket(posTicket) && PositionGetString(POSITION_SYMBOL) == symbol)
            posCount++;
      }
      return posCount;
   }
};

// Stub minimal du StrategyManager
class CStrategyManager
{
public:
   double GetSpreadPips()               { return 0.0; }
   double GetDynamicSpreadThreshold()   { return 9999; }
   bool   UpdateIndicators()            { return true; }
   bool   GenerateSignal(STradeSignal&) { return false; }
} strategyManager;

//========================================================================
// SECTION 6 : INSTANCES GLOBALES ET UTILITAIRES
//========================================================================

/// Gestionnaire de risque initialisé avec les inputs
CRiskManager riskManager(MaxDailyLossPercent,
                         MaxLossPercent,
                         MaxConsecutiveLosses,
                         PauseAfterLosses,
                         PauseDurationMinutes);

/// Pointeur vers le TradeManager (créé dans OnInit)
CTradeManager *tradeManager = NULL;

//+------------------------------------------------------------------+
//| Fonctions utilitaires                                           |
//+------------------------------------------------------------------+

// Formatte un nombre avec signe (+ ou -)
string FormatSigned(double value, int digits=2) {
    string sign = value >= 0 ? "+" : "-";
    return sign + DoubleToString(MathAbs(value), digits);
}

// Convertit un timestamp en date seule (sans heures/minutes/secondes)
datetime DateOfDay(datetime t) {
   MqlDateTime str;
   TimeToStruct(t, str);
   str.hour = 0;
   str.min = 0;
   str.sec = 0;
   return StructToTime(str);
}

// Retourne la dernière stratégie utilisée
string LastStrategyUsed() {
   string lastStrategy = "Aucune";
   datetime lastTime = 0;
   
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].lastTradeTime > lastTime) {
         lastTime = strategyPerformance[i].lastTradeTime;
         lastStrategy = EnumToString(strategyPerformance[i].strategy);
      }
   }
   return lastStrategy;
}

// Obtient les statistiques du jour
void GetTodayStats(int &totalTrades, int &winTrades, int &lossTrades) {
   totalTrades = 0;
   winTrades = 0;
   lossTrades = 0;

   datetime today = DateOfDay(TimeCurrent());
   int deals = HistoryDealsTotal();
   
   for(int i = 0; i < deals; i++) {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket == 0) continue;
      
      datetime dealTime = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
      if(DateOfDay(dealTime) < today) break;
      
      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
      totalTrades++;
      
      if(profit > 0) winTrades++;
      else if(profit < 0) lossTrades++;
   }
}

// Calcule le profit du jour
double GetDailyProfit() {
   double profitToday = 0.0;
   datetime today = DateOfDay(TimeCurrent());
   int deals = HistoryDealsTotal();
   
   for(int i = 0; i < deals; i++) {
      ulong ticket = HistoryDealGetTicket(i);
      if(ticket == 0) continue;
      
      datetime dealTime = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
      if(DateOfDay(dealTime) < today) break;
      
      profitToday += HistoryDealGetDouble(ticket, DEAL_PROFIT);
   }
   return profitToday;
}

// Calcule le taux de réussite global
double CalculateWinRate() {
   int totalTrades = 0;
   int winningTrades = 0;

   int totalHistory = HistoryDealsTotal();
   
   for(int i = 0; i < totalHistory; i++) {
      ulong dealTicket = HistoryDealGetTicket(i);
      if(dealTicket > 0) {
         double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
         if(profit != 0) {  // On ignore les trades avec profit=0
            totalTrades++;
            if(profit > 0) {
               winningTrades++;
            }
         }
      }
   }

   if(totalTrades > 0) {
      return (double)winningTrades / totalTrades * 100.0;
   }
   return 0.0;
}

// Charge les performances des stratégies
void LoadStrategyPerformance() 
{
    for(int i = 0; i < STRATEGY_COUNT; i++) 
    {
        // Crée un préfixe unique pour chaque stratégie
        string prefix = "STRAT_" + EnumToString(strategyPerformance[i].strategy) + "_";
        
        // Charge les données depuis les variables globales
        strategyPerformance[i].wins = (int)GlobalVariableGet(prefix + "WINS");
        strategyPerformance[i].losses = (int)GlobalVariableGet(prefix + "LOSSES");
        strategyPerformance[i].totalTrades = (int)GlobalVariableGet(prefix + "TOTAL");
        strategyPerformance[i].totalProfit = GlobalVariableGet(prefix + "PROFIT");
        strategyPerformance[i].lastTradeTime = (datetime)GlobalVariableGet(prefix + "LAST_TIME");
        
        // Initialise les valeurs si elles n'existent pas
        if(strategyPerformance[i].totalTrades == 0 && GlobalVariableCheck(prefix + "TOTAL") == false)
        {
            strategyPerformance[i].wins = 0;
            strategyPerformance[i].losses = 0;
            strategyPerformance[i].totalTrades = 0;
            strategyPerformance[i].totalProfit = 0.0;
            strategyPerformance[i].lastTradeTime = 0;
        }
    }
}

// Sauvegarde les performances des stratégies dans les variables globales
void SaveStrategyPerformance() 
{
    for(int i = 0; i < STRATEGY_COUNT; i++) 
    {
        // Crée un préfixe unique pour chaque stratégie
        string prefix = "STRAT_" + EnumToString(strategyPerformance[i].strategy) + "_";
        
        // Sauvegarde les données dans les variables globales
        GlobalVariableSet(prefix + "WINS", strategyPerformance[i].wins);
        GlobalVariableSet(prefix + "LOSSES", strategyPerformance[i].losses);
        GlobalVariableSet(prefix + "TOTAL", strategyPerformance[i].totalTrades);
        GlobalVariableSet(prefix + "PROFIT", strategyPerformance[i].totalProfit);
        GlobalVariableSet(prefix + "LAST_TIME", (double)strategyPerformance[i].lastTradeTime);
    }
}

// Met à jour les poids des stratégies pour la sélection dynamique
void UpdateStrategyWeights() 
{
    for(int i = 0; i < STRATEGY_COUNT; i++) 
    {
        if(strategyPerformance[i].totalTrades > 0) 
        {
            // Calcule le taux de réussite récent (20 derniers trades)
            double recentWinRate = strategyPerformance[i].wins / (double)MathMax(20, strategyPerformance[i].totalTrades) * 100.0;
            
            // Calcule le taux de réussite moyen (100 derniers trades)
            double mediumWinRate = strategyPerformance[i].wins / (double)MathMax(100, strategyPerformance[i].totalTrades) * 100.0;
            
            // Calcule un facteur de volatilité basé sur l'ATR
            double atr = iATR(_Symbol, _Period, 14);
            double volatilityFactor = (atr > 0.0005) ? 1.2 : (atr < 0.0002) ? 0.8 : 1.0;
            
            // Combine les facteurs pour obtenir le poids final (50% récent, 30% moyen, 20% volatilité)
            strategyPerformance[i].weight = recentWinRate * 0.5 + mediumWinRate * 0.3 + volatilityFactor * 0.2;
        }
        else
        {
            // Poids par défaut si aucune donnée disponible
            strategyPerformance[i].weight = 1.0;
        }
    }
}

// Gère automatiquement l'activation/désactivation des stratégies
void AutoManageStrategies() 
{
    for(int i = 0; i < STRATEGY_COUNT; i++) 
    {
        if(strategyPerformance[i].totalTrades >= MinTradesToDisable) 
        {
            // Calcule le taux de réussite actuel
            strategyPerformance[i].winRate = (double)strategyPerformance[i].wins / strategyPerformance[i].totalTrades * 100.0;
            
            // Désactive la stratégie si le taux de réussite est trop bas
            if(strategyPerformance[i].winRate < MinWinRateToDisable && strategyPerformance[i].enabled) 
            {
                strategyPerformance[i].enabled = false;
                strategyPerformance[i].lastTradeTime = TimeCurrent();
                
                if(EnableNotifications) 
                {
                    Alert(_Symbol + " " + EnumToString(_Period) + ": Strategy Disabled: " + 
                          EnumToString(strategyPerformance[i].strategy) + 
                          " (Win Rate: " + DoubleToString(strategyPerformance[i].winRate, 1) + "%)");
                }
            }
            
            // Réactive la stratégie après le délai spécifié
            if(!strategyPerformance[i].enabled && 
               TimeCurrent() - strategyPerformance[i].lastTradeTime > ReEnableAfterHours * 3600) 
            {
                strategyPerformance[i].enabled = true;
                
                if(EnableNotifications) 
                {
                    Alert(_Symbol + " " + EnumToString(_Period) + ": Strategy Re-enabled: " + 
                          EnumToString(strategyPerformance[i].strategy));
                }
            }
        }
    }
}

//========================================================================
// SECTION 7 : FONCTIONS DU DASHBOARD
//========================================================================

// Dessine une barre de progression
void DrawProgressBar(string name, int x, int y, double percent, color clrPositive, color clrNegative) {
    int width = 150;
    int height = 15;
    
    ObjectCreate(0, name+"_BG", OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name+"_BG", OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name+"_BG", OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name+"_BG", OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name+"_BG", OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name+"_BG", OBJPROP_COLOR, clrGray);
    ObjectSetInteger(0, name+"_BG", OBJPROP_BACK, true);
    
    int progressWidth = (int)(width * percent / 100.0);
    ObjectCreate(0, name+"_FG", OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name+"_FG", OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name+"_FG", OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name+"_FG", OBJPROP_XSIZE, progressWidth);
    ObjectSetInteger(0, name+"_FG", OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name+"_FG", OBJPROP_COLOR, percent >= 50 ? clrPositive : clrNegative);
    ObjectSetInteger(0, name+"_FG", OBJPROP_BACK, false);
}

// Crée un bouton
void CreateButton(string name, string text, int x, int y, int width, int height, color bgColor) {
    ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name, OBJPROP_COLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_BACK, false);
    
    ObjectCreate(0, name+"_TXT", OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_XDISTANCE, x + width/2 - StringLen(text)*3);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_YDISTANCE, y + height/2 - 8);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_FONTSIZE, 10);
    ObjectSetString(0, name+"_TXT", OBJPROP_TEXT, text);
}

// Dessine l'arrière-plan du dashboard
void DrawDashboardBackground(int x, int y, int width, int height) {
   string bgName = "DASHBOARD_BG";
   ObjectDelete(0, bgName);
   ObjectCreate(0, bgName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, bgName, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, bgName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, bgName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, bgName, OBJPROP_XSIZE, width);
   ObjectSetInteger(0, bgName, OBJPROP_YSIZE, height);
   ObjectSetInteger(0, bgName, OBJPROP_COLOR, C'10,20,40');
   ObjectSetInteger(0, bgName, OBJPROP_BACK, true);
   ObjectSetInteger(0, bgName, OBJPROP_SELECTABLE, false);
}

// Met à jour le dashboard
void UpdateDashboard() {
   // Supprime d'abord l'ancien tableau de bord
   DeleteDashboard();

   // Position initiale du tableau de bord
   int x = DashboardPosX;
   int y = DashboardPosY;

   // Crée le panneau principal du tableau de bord
   ObjectCreate(0, "DASHBOARD_PANEL", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XSIZE, DashboardWidth);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YSIZE, DashboardHeight + 150);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_CORNER, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_COLOR, C'30,30,30');
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_BACK, true);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_SELECTABLE, false);

   // Décalage vertical pour les éléments suivants
   y += 15;
   int fontSize = 12;

   // Affiche les informations de base (paire et timeframe)
   string header = "PAIR: " + _Symbol + " | TF: " + EnumToString(_Period);
   DisplayLabel("DASHBOARD_PAIR_TF", header, x + 15, y, clrGold, fontSize);
   y += 20;

   // Affiche la stratégie utilisée
   string strategy = "STRATEGY: " + LastStrategyUsed();
   DisplayLabel("DASHBOARD_STRATEGY", strategy, x + 15, y, clrWhite, fontSize);
   y += 20;

   // Affiche le solde et l'equity du compte
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   DisplayLabel("DASHBOARD_BALANCE", "BALANCE: " + DoubleToString(balance, 2), x + 15, y, clrWhite, fontSize);
   y += 20;
   DisplayLabel("DASHBOARD_EQUITY", "EQUITY: " + DoubleToString(equity, 2), x + 15, y, clrWhite, fontSize);
   y += 20;

   // Affiche le profit du jour avec couleur conditionnelle
   double profitToday = GetDailyProfit();
   color profitColor = profitToday >= 0 ? clrLime : clrOrange;
   DisplayLabel("DASHBOARD_PROFIT_DAY", "DAILY PROFIT: " + FormatSigned(profitToday, 2), x + 15, y, profitColor, fontSize, true);
   y += 20;

   // Affiche le spread actuel
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   DisplayLabel("DASHBOARD_SPREAD", "CURRENT SPREAD: " + DoubleToString(spread, Digits()), x + 15, y, clrWhite, fontSize);
   y += 20;

   // Séparateur pour les statistiques quotidiennes
   y += 10;
   DisplayLabel("DASHBOARD_SEPARATOR", "----------- DAILY STATISTICS -----------", x + 15, y, clrAqua, fontSize);
   y += 20;

   // Récupère et affiche les statistiques quotidiennes
   int totalTradesToday, winTradesToday, lossTradesToday;
   GetTodayStats(totalTradesToday, winTradesToday, lossTradesToday);

   DisplayLabel("DASHBOARD_TODAY_TRADES", "TOTAL TRADES TODAY: " + IntegerToString(totalTradesToday), x + 15, y, clrWhite, fontSize);
   y += 20;

   DisplayLabel("DASHBOARD_TODAY_WINS", "WINS: " + IntegerToString(winTradesToday) + " | LOSSES: " + IntegerToString(lossTradesToday), x + 15, y, clrWhite, fontSize);
   y += 20;

   // Affiche le P/L du jour avec couleur conditionnelle
   double plToday = GetDailyProfit();
   double winRateToday = totalTradesToday > 0 ? 100.0 * winTradesToday / totalTradesToday : 0.0;
   DisplayLabel("DASHBOARD_TODAY_PL", "P/L TODAY: " + FormatSigned(plToday, 2), x + 15, y, plToday >= 0 ? clrLime : clrOrange, fontSize, true);
   y += 20;

   // Barre de progression pour le taux de réussite
   DrawProgressBar("WINRATE_BAR", x + 15, y, winRateToday, clrGreen, clrRed);
   DisplayLabel("DASHBOARD_WINRATE", "WIN RATE TODAY: " + DoubleToString(winRateToday, 1) + "%", x + 220, y, clrYellow, fontSize);
   y += 30;

   // Statut de l'EA avec couleur conditionnelle
   string status = ea_is_active ? "ACTIVE" : "PAUSED";
   color statusColor = ea_is_active ? clrLime : clrRed;
   DisplayLabel("DASHBOARD_STATUS", "STATUS: " + status, x + 15, y, statusColor, 14, true);
   y += 30;
}

// Fonction pour supprimer le tableau de bord et tous ses éléments
void DeleteDashboard() {
   // Supprime le panneau principal
   ObjectDelete(0, "DASHBOARD_PANEL");

   // Liste de tous les éléments du tableau de bord à supprimer
   string elements[] = {
      "DASHBOARD_PAIR_TF",
      "DASHBOARD_STRATEGY",
      "DASHBOARD_BALANCE",
      "DASHBOARD_EQUITY",
      "DASHBOARD_PROFIT_DAY",
      "DASHBOARD_SPREAD",
      "DASHBOARD_SEPARATOR",
      "DASHBOARD_TODAY_TRADES",
      "DASHBOARD_TODAY_WINS",
      "DASHBOARD_TODAY_PL",
      "WINRATE_BAR_BG",
      "WINRATE_BAR_FG",
      "DASHBOARD_WINRATE",
      "DASHBOARD_STATUS",
      "DASHBOARD_TOGGLE",
      "DASHBOARD_TOGGLE_TXT",
      "DASHBOARD_CLOSE",
      "DASHBOARD_CLOSE_TXT"
   };

   // Parcourt tous les éléments et les supprime
   for(int i = 0; i < ArraySize(elements); i++) {
      ObjectDelete(0, elements[i]);
   }
}

// Fonction pour afficher un label
void DisplayLabel(string name, string text, int x, int y, color txtColor, int size, bool bold=false) {
   // Crée l'objet label
   ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
   
   // Configure ses propriétés
   ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, name, OBJPROP_COLOR, txtColor);
   ObjectSetInteger(0, name, OBJPROP_FONTSIZE, size);
   ObjectSetInteger(0, name, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
   
   // Option pour le texte en gras
   ObjectSetInteger(0, name, OBJPROP_BOLD, bold ? true : false);
   
   // Définit le texte du label
   ObjectSetString(0, name, OBJPROP_TEXT, text);
}

//========================================================================
// SECTION 8 : FONCTIONS PRINCIPALES DE L'EA
//========================================================================

//+------------------------------------------------------------------+
//| Fonction d'initialisation                                       |
//+------------------------------------------------------------------+
int OnInit() {
    // 1. Vérification des symboles autorisés
    string allowedSymbols[] = {"EURUSDm", "USDJPYm", "EURGBPm", "XAUUSDm", "GOLDm", "BTCUSD"};
    bool symbolAllowed = false;
    for(int i = 0; i < ArraySize(allowedSymbols); i++) {
        if(Symbol() == allowedSymbols[i]) {
            symbolAllowed = true;
            break;
        }
    }
    if(!symbolAllowed) {
        PrintFormat("Le symbole %s n'est pas autorisé pour cet EA.", Symbol());
        return(INIT_FAILED);
    }
    
    // 2. Création de l'instance du TradeManager
    tradeManager = new CTradeManager(&riskManager,
                                    MinLotsAllowed,
                                    MaxLotsAllowed,
                                    MaxPositionsPerSymbol,
                                    MagicNumber,
                                    Slippage,
                                    ATRPeriod,
                                    EnableNotifications,
                                    EnableSound,
                                    MinMinutesBetweenTrades);

    // 3. Initialisation des variables globales
    g_LastEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
    g_LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    g_ATRValue    = 0.0;
    g_IsGold      = (StringFind(_Symbol, "GOLD") >= 0 || StringFind(_Symbol, "XAUUSDm") >= 0);

    // 4. Initialisation du tableau strategyPerformance
    ArrayResize(strategyPerformance, STRATEGY_COUNT);
    for(int i = 0; i < STRATEGY_COUNT; i++) {
        strategyPerformance[i].strategy = (ENUM_STRATEGY)(i);
        strategyPerformance[i].enabled  = true;
        strategyPerformance[i].weight   = 1.0;
    }

    EnableSuperTrend = EnableSuperTrendInput;
    
    // 5. Initialisation du tableau strategies
    strategies_total = 0;
    ArrayResize(strategies, STRATEGY_COUNT);

    for(int i = 0; i < STRATEGY_COUNT; i++) {
        StrategyStats s;
        s.Enabled     = true;
        s.TotalTrades = 0;
        s.Wins        = 0;
        s.Losses      = 0;
        s.Profit      = 0.0;
        s.WinRate     = 0.0;
        s.StatusColor = clrSilver;

        switch(i) {
            case STRAT_CHECKLIST:
                s.Name        = "Checklist";
                s.StatusColor = clrLime;
                break;

            case STRAT_BREAKOUT_RANGE:
                s.Name        = "Breakout";
                s.StatusColor = clrGold;
                break;

            case STRAT_PULLBACK_EMA:
                s.Name        = "Pullback EMA";
                s.StatusColor = clrOrange;
                break;

            case STRAT_SUPERTREND:
                s.Name        = "SuperTrend";
                s.StatusColor = clrDeepSkyBlue;
                break;

            case STRAT_RETEST_SR:
                s.Name        = "Retest SR";
                s.StatusColor = clrDodgerBlue;
                break;

            case STRAT_SCALPING:
                s.Name        = "Scalping";
                s.StatusColor = clrViolet;
                break;
        }

        strategies[strategies_total++] = s;
    }
    
    // Ajouter dans OnInit() après l'initialisation des variables globales
    macdHandle = iMACD(_Symbol, _Period, Checklist_MACD_Fast, Checklist_MACD_Slow, Checklist_MACD_Signal, PRICE_CLOSE);
    rsiHandle = iRSI(_Symbol, _Period, 14, PRICE_CLOSE);
    if(macdHandle == INVALID_HANDLE || rsiHandle == INVALID_HANDLE) {
    Print("Erreur lors de la création des indicateurs");
    return INIT_FAILED;
    }
    
    // 6. Chargement des performances enregistrées et timer
    LoadStrategyPerformance();
    EventSetTimer(10);

    return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Fonction de dé-initialisation de l'Expert Advisor               |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
    // 1. Sauvegarde des statistiques des stratégies
    SaveStrategyPerformance();

    // 2. Nettoyage du tableau de bord et des objets graphiques
    DeleteDashboard();
    ObjectsDeleteAll(0, "Dashboard_", 0, OBJ_LABEL | OBJ_BUTTON);

    // 3. Arrêt du timer événementiel
    EventKillTimer();

    // 4. Libération de la mémoire du TradeManager
    if(tradeManager != NULL) {
        delete tradeManager;
        tradeManager = NULL;
    }

    // 5. Message de journal pour confirmation
    string msg;
    switch(reason) {
        case REASON_REMOVE:      msg = "EA retiré manuellement.";           break;
        case REASON_RECOMPILE:   msg = "EA recompilé.";                     break;
        case REASON_CHARTCHANGE: msg = "Changement de symbole ou timeframe."; break;
        case REASON_CHARTCLOSE:  msg = "Fermeture du graphique.";           break;
        case REASON_PARAMETERS:  msg = "Paramètres modifiés.";              break;
        case REASON_ACCOUNT:     msg = "Changement de compte.";             break;
        case REASON_CLOSE:       msg = "Fermeture de la plateforme.";       break;
        default:                 msg = "Raison inconnue.";                  break;
    }
    PrintFormat("OnDeinit() terminé : %s", msg);
}

//+------------------------------------------------------------------+
//| Fonction exécutée à chaque tick                                 |
//+------------------------------------------------------------------+
void OnTick() {
    // 1. INITIALISATION & JOURNALISATION (une fois tous les 100 ticks)
    static uint tickCount = 0;
    tickCount++;

    if(EnableDebugLog && (tickCount % 100 == 0)) {
        double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        double spr = (ask - bid) / _Point;

        PrintFormat("Tick %u — Bid=%.5f Ask=%.5f Spread=%.1f points",
                    tickCount, bid, ask, spr);
    }

    // 2. VÉRIFICATION DE L'ÉTAT DE L'EA (connexion, trading autorisé)
    if(!IsConnected() || TerminalInfoInteger(TERMINAL_TRADE_ALLOWED) == 0)
        return;

    // 3. CONTRÔLE DU SPREAD — on ne trade pas si le spread est trop haut
    double spreadPips      = strategyManager.GetSpreadPips();
    double maxSpreadPips   = strategyManager.GetDynamicSpreadThreshold();

    if(spreadPips > maxSpreadPips) {
        if(EnableDebugLog)
            Comment("Spread trop élevé : ", DoubleToString(spreadPips,1),
                    " pips (max = ", DoubleToString(maxSpreadPips,1), ")");
        return;
    }

    // 4. MISE À JOUR DU TABLEAU DE BORD (toutes les 1 s)
    static datetime lastDashboardUpdate = 0;
    if(TimeCurrent() - lastDashboardUpdate >= 1) {
        UpdateDashboard();
        lastDashboardUpdate = TimeCurrent();
    }

    // 5. VÉRIFICATION DE LA DISPONIBILITÉ DES DONNÉES
    if(Bars(_Symbol, _Period) < 100) {
        if(EnableDebugLog)
            PrintFormat("Pas assez de données : %s (%d barres)",
                        _Symbol, Bars(_Symbol, _Period));
        return;
    }

    // 6. MISE À JOUR PÉRIODIQUE DES INDICATEURS (toutes les 10 s)
    static datetime lastIndicatorCheck = 0;
    if(TimeCurrent() - lastIndicatorCheck >= 10) {
        if(!strategyManager.UpdateIndicators()) {
            Alert("Échec critique de l'initialisation des indicateurs !");
            return;
        }
        lastIndicatorCheck = TimeCurrent();
    }

    // 7. ACTUALISATION DE L'ATR GLOBAL
    double atr = iATR(_Symbol, _Period, ATRPeriod, 0);
    if(!MathIsNaN(atr))
        g_ATRValue = atr;
    else if(EnableDebugLog)
        Print("ATR indisponible – g_ATRValue inchangé.");

    // 8. SORTIES INTELLIGENTES (break-even, trailing, etc.)
    CheckIntelligentExit();

    // 9. GESTION DES POSITIONS EXISTANTES (stops, break-even, etc.)
    if(tradeManager != NULL) {
        tradeManager.ManagePositions();
    }

    // 10. GÉNÉRATION & EXÉCUTION DES SIGNAUX
    STradeSignal signal;
    if(strategyManager.GenerateSignal(signal) && signal.valid) {
        if(EnableDebugLog)
            PrintFormat("Signal %s détecté : price=%.5f SL=%.5f TP=%.5f",
                        signal.isBuySignal ? "BUY" : "SELL",
                        signal.price, signal.sl, signal.tp);

        // 10.1 Calcul de la taille de lot
        double lots = riskManager.CalculatePositionSize(signal.price, signal.sl);
        lots = MathMax(MinLotsAllowed, MathMin(MaxLotsAllowed, lots));

        // 10.2 Exécution de l'ordre
        bool tradeResult = false;
        if(tradeManager != NULL) {
            tradeResult = tradeManager.ExecuteTrade(signal);
        }

        // 10.3 Gestion d'erreur
        if(!tradeResult) {
            int err = GetLastError();
            PrintFormat("Échec du trade : %d (%s)", err, ErrorDescription(err));
            ResetLastError();
        }
        else if(EnableDebugLog) {
            PrintFormat("Trade %s exécuté (%.2f lots)",
                        signal.isBuySignal ? "BUY" : "SELL", lots);
        }
    }

    // 11. VÉRIFICATION DES STOPS (toujours, même sans nouveau signal)
    if(tradeManager != NULL) {
        tradeManager.ManageStops();
    }
}

//+------------------------------------------------------------------+
//| Helper — description lisible des codes-erreurs                   |
//+------------------------------------------------------------------+
string ErrorDescription(int errorCode) {
    switch(errorCode) {
        case 0:     return "OK (0)";
        case 1:     return "ERR_NO_RESULT (1)";
        case 2:     return "ERR_COMMON_ERROR (2)";
        case 3:     return "ERR_INVALID_TRADE_PARAMETERS (3)";
        case 4:     return "ERR_SERVER_BUSY (4)";
        case 5:     return "ERR_OLD_VERSION (5)";
        case 6:     return "ERR_NO_CONNECTION (6)";
        case 7:     return "ERR_NOT_ENOUGH_RIGHTS (7)";
        case 8:     return "ERR_TOO_FREQUENT_REQUESTS (8)";
        case 9:     return "ERR_MALFUNCTIONAL_TRADE (9)";
        case 64:    return "ERR_ACCOUNT_DISABLED (64)";
        case 65:    return "ERR_INVALID_ACCOUNT (65)";
        case 128:   return "ERR_TRADE_TIMEOUT (128)";
        case 129:   return "ERR_INVALID_PRICE (129)";
        case 130:   return "ERR_INVALID_STOPS (130)";
        case 131:   return "ERR_INVALID_TRADE_VOLUME (131)";
        case 132:   return "ERR_MARKET_CLOSED (132)";
        case 133:   return "ERR_TRADE_DISABLED (133)";
        case 134:   return "ERR_NOT_ENOUGH_MONEY (134)";
        case 135:   return "ERR_PRICE_CHANGED (135)";
        case 136:   return "ERR_OFF_QUOTES (136)";
        case 137:   return "ERR_BROKER_BUSY (137)";
        case 138:   return "ERR_REQUOTE (138)";
        case 139:   return "ERR_ORDER_LOCKED (139)";
        case 140:   return "ERR_LONG_POSITIONS_ONLY_ALLOWED (140)";
        case 141:   return "ERR_TOO_MANY_REQUESTS (141)";
        case 145:   return "ERR_TRADE_MODIFY_DENIED (145)";
        case 146:   return "ERR_TRADE_CONTEXT_BUSY (146)";
        case 147:   return "ERR_TRADE_EXPIRATION_DENIED (147)";
        case 148:   return "ERR_TRADE_TOO_MANY_ORDERS (148)";
        case 4000:  return "ERR_NO_MQLERROR (4000)";
        case 4001:  return "ERR_WRONG_FUNCTION_POINTER (4001)";
        case 4002:  return "ERR_ARRAY_INDEX_OUT_OF_RANGE (4002)";
        case 4003:  return "ERR_NO_MEMORY_FOR_CALL_STACK (4003)";
        case 4004:  return "ERR_RECURSIVE_STACK_OVERFLOW (4004)";
        case 4005:  return "ERR_NOT_ENOUGH_STACK_FOR_PARAM (4005)";
        case 4006:  return "ERR_NO_MEMORY_FOR_PARAM_STRING (4006)";
        case 4007:  return "ERR_NO_MEMORY_FOR_TEMP_STRING (4007)";
        case 4008:  return "ERR_NOT_INITIALIZED_STRING (4008)";
        case 4009:  return "ERR_NOT_INITIALIZED_ARRAYSTRING (4009)";
        case 4010:  return "ERR_NO_MEMORY_FOR_ARRAYSTRING (4010)";
        case 4011:  return "ERR_TOO_LONG_STRING (4011)";
        case 4012:  return "ERR_REMAINDER_FROM_ZERO_DIVIDE (4012)";
        case 4013:  return "ERR_ZERO_DIVIDE (4013)";
        case 4014:  return "ERR_UNKNOWN_COMMAND (4014)";
        case 4015:  return "ERR_WRONG_JUMP (4015)";
        case 4016:  return "ERR_NOT_INITIALIZED_ARRAY (4016)";
        case 4017:  return "ERR_DLL_CALLS_NOT_ALLOWED (4017)";
        case 4018:  return "ERR_CANNOT_LOAD_LIBRARY (4018)";
        case 4019:  return "ERR_CANNOT_CALL_FUNCTION (4019)";
        case 4020:  return "ERR_EXTERNAL_CALLS_NOT_ALLOWED (4020)";
        case 4021:  return "ERR_NO_MEMORY_FOR_RETURNED_STR (4021)";
        case 4022:  return "ERR_SYSTEM_BUSY (4022)";
        case 4050:  return "ERR_INVALID_FUNCTION_PARAMSCNT (4050)";
        case 4051:  return "ERR_INVALID_FUNCTION_PARAMVALUE (4051)";
        case 4052:  return "ERR_STRING_FUNCTION_INTERNAL (4052)";
        case 4053:  return "ERR_SOME_ARRAY_ERROR (4053)";
        case 4054:  return "ERR_INCORRECT_SERIESARRAY_USING (4054)";
        case 4055:  return "ERR_CUSTOM_INDICATOR_ERROR (4055)";
        case 4056:  return "ERR_INCOMPATIBLE_ARRAYS (4056)";
        case 4057:  return "ERR_GLOBAL_VARIABLES_PROCESSING (4057)";
        case 4058:  return "ERR_GLOBAL_VARIABLE_NOT_FOUND (4058)";
        case 4059:  return "ERR_FUNC_NOT_ALLOWED_IN_TESTING (4059)";
        case 4060:  return "ERR_FUNCTION_NOT_CONFIRMED (4060)";
        case 4061:  return "ERR_SEND_MAIL_ERROR (4061)";
        case 4062:  return "ERR_STRING_PARAMETER_EXPECTED (4062)";
        case 4063:  return "ERR_INTEGER_PARAMETER_EXPECTED (4063)";
        case 4064:  return "ERR_DOUBLE_PARAMETER_EXPECTED (4064)";
        case 4065:  return "ERR_ARRAY_AS_PARAMETER_EXPECTED (4065)";
        case 4066:  return "ERR_HISTORY_WILL_UPDATED (4066)";
        case 4067:  return "ERR_TRADE_ERROR (4067)";
        case 4099:  return "ERR_END_OF_FILE (4099)";
        case 4100:  return "ERR_SOME_FILE_ERROR (4100)";
        case 4101:  return "ERR_WRONG_FILE_NAME (4101)";
        case 4102:  return "ERR_TOO_MANY_OPENED_FILES (4102)";
        case 4103:  return "ERR_CANNOT_OPEN_FILE (4103)";
        case 4104:  return "ERR_INCOMPATIBLE_FILEACCESS (4104)";
        case 4105:  return "ERR_NO_ORDER_SELECTED (4105)";
        case 4106:  return "ERR_UNKNOWN_SYMBOL (4106)";
        case 4107:  return "ERR_INVALID_PRICE_PARAM (4107)";
        case 4108:  return "ERR_INVALID_TICKET (4108)";
        case 4109:  return "ERR_TRADE_NOT_ALLOWED (4109)";
        case 4110:  return "ERR_LONGS_NOT_ALLOWED (4110)";
        case 4111:  return "ERR_SHORTS_NOT_ALLOWED (4111)";
        case 4200:  return "ERR_OBJECT_ALREADY_EXISTS (4200)";
        case 4201:  return "ERR_UNKNOWN_OBJECT_PROPERTY (4201)";
        case 4202:  return "ERR_OBJECT_DOES_NOT_EXIST (4202)";
        case 4203:  return "ERR_UNKNOWN_OBJECT_TYPE (4203)";
        case 4204:  return "ERR_NO_OBJECT_NAME (4204)";
        case 4205:  return "ERR_OBJECT_COORDINATES_ERROR (4205)";
        case 4206:  return "ERR_NO_SPECIFIED_SUBWINDOW (4206)";
        case 4207:  return "ERR_SOME_OBJECT_ERROR (4207)";
        case 4753:  return "STOPS_INVALID (4753)";
        case 4756:  return "INVALID_VOLUME (4756)";
        case 10030: return "NOT_ENOUGH_MARGIN (10030)";
        case 10013: return "MARKET_CLOSED (10013)";
        case 10004: return "ORDER_REJECTED (10004)";
        default:    return "UNKNOWN_ERROR (" + IntegerToString(errorCode) + ")";
    }
}

//+------------------------------------------------------------------+
//| Fonction timer                                                  |
//+------------------------------------------------------------------+
void OnTimer() {
    AutoManageStrategies();
    UpdateStrategyWeights();
    UpdateDashboard();
}

//+------------------------------------------------------------------+
//| Gestion des événements du chart                                 |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                 const long &lparam,
                 const double &dparam,
                 const string &sparam) {
    if(id == CHARTEVENT_OBJECT_CLICK) {
        string obj_name = sparam;
        if(obj_name == "DASHBOARD_TOGGLE") {
            ea_is_active = !ea_is_active;
            Comment("EA " + (ea_is_active ? "Activé" : "Désactivé"));
        }
    }
}

//========================================================================
// SECTION 9 : FONCTIONS SUPPLEMENTAIRES
//========================================================================

//+------------------------------------------------------------------+
//| Ouvre un trade via le TradeManager global                        |
//+------------------------------------------------------------------+
bool OpenTrade(const STradeSignal &signal) {
    // Vérification de l'instance globale
    if(tradeManager == NULL) {
        Print("❌ tradeManager non initialisé !");
        return false;
    }

    // Appelle la méthode ExecuteTrade() déjà codée dans CTradeManager
    return tradeManager.ExecuteTrade(signal);
}

//+------------------------------------------------------------------+
//| Ferme toutes les positions ouvertes                              |
//+------------------------------------------------------------------+
void PerformFullClose() {
    int total = PositionsTotal();

    for(int i = total - 1; i >= 0; i--) {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0) continue;

        if(PositionSelectByTicket(ticket)) {
            string pos_symbol = PositionGetString(POSITION_SYMBOL);
            int    pos_magic  = (int)PositionGetInteger(POSITION_MAGIC);

            // On ne ferme que les positions du symbole & MagicNumber de l'EA
            if(pos_symbol == _Symbol && pos_magic == MagicNumber)
                trade.PositionClose(ticket);
        }
    }
}

//+------------------------------------------------------------------+
//| Vérifie les conditions pour une sortie intelligente              |
//+------------------------------------------------------------------+
void CheckIntelligentExit() {
    double totalProfit = 0.0;
    int    openPositions = 0;

    for(int i = (int)PositionsTotal()-1; i >= 0; --i) {
        ulong ticket = PositionGetTicket(i);
        if(ticket == 0) continue;

        if(PositionSelectByTicket(ticket)) {
            if(PositionGetString(POSITION_SYMBOL) == _Symbol &&
               (int)PositionGetInteger(POSITION_MAGIC) == MagicNumber) {
                totalProfit += PositionGetDouble(POSITION_PROFIT);
                ++openPositions;
            }
        }
    }

    double balance  = AccountInfoDouble(ACCOUNT_BALANCE);
    double equity   = AccountInfoDouble(ACCOUNT_EQUITY);
    double drawdown = (balance == 0) ? 0.0 : (balance - equity) / balance * 100.0;

    bool mustExit = (drawdown >= MaxDailyLossPercent) ||
                    DetectMarketAnomaly() ||
                    (totalProfit >= balance * 0.05);

    if(mustExit && openPositions > 0) {
        PrintFormat("🔔 Sortie intelligente : DD=%.1f%% | Profit=%.2f", drawdown, totalProfit);
        PerformFullClose();
    }
}

//+------------------------------------------------------------------+
//| Détecte les anomalies du marché                                 |
//+------------------------------------------------------------------+
bool DetectMarketAnomaly() {
    // 1) Spread extrême
    double spreadPts = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
    if(spreadPts > strategyManager.GetDynamicSpreadThreshold())
        return true;

    // 2) Pic de volatilité ATR
    double atr = iATR(_Symbol, _Period, 14);
    double meanATR = 0.0;
    for(int i = 1; i <= 100; i++)
        meanATR += iATR(_Symbol, _Period, 14, i);
    meanATR /= 100.0;

    return (atr > meanATR * 1.8);
}

//+------------------------------------------------------------------+
//| Journalisation avancée                                          |
//+------------------------------------------------------------------+
void AdvancedLogging() {
    static datetime lastLog = 0;
    if(TimeCurrent() - lastLog < 300) return; // 1 log / 5 min

    string log;
    log = "=== DIAMOND LOG ===\n";
    log += "Time    : " + TimeToString(TimeCurrent(), TIME_DATE|TIME_SECONDS) + "\n";
    log += "Balance : " + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2) + "\n";
    log += "Equity  : " + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2) + "\n";

    for(int i = 0; i < STRATEGY_COUNT; i++)
        log += StringFormat("- %s : %d trades | WR=%.1f%% | PF=%.2f\n",
                            EnumToString(strategyPerformance[i].strategy),
                            strategyPerformance[i].totalTrades,
                            strategyPerformance[i].winRate,
                            strategyPerformance[i].profitFactor);

    int h = FileOpen("DiamondEA_Log.txt", FILE_TXT|FILE_WRITE|FILE_READ);
    if(h != INVALID_HANDLE) {
        FileSeek(h, 0, SEEK_END);
        FileWrite(h, log);
        FileClose(h);
    }

    lastLog = TimeCurrent();
}

//+------------------------------------------------------------------+
//| Money-management dynamique                                      |
//+------------------------------------------------------------------+
void AdvancedMoneyManagement() {
    double balance = AccountInfoDouble(ACCOUNT_BALANCE);
    double equity  = AccountInfoDouble(ACCOUNT_EQUITY);
    if(balance == 0) return;

    double dd = (balance - equity) / balance * 100.0;
    if(dd > (MaxDailyLossPercent / 2.0)) {
        // Réduit le risque si le drawdown est important
        // Note: On ne peut pas modifier directement un input (RiskPercent)
        // Donc on pourrait utiliser une variable globale alternative
        Print("⚠️ Drawdown élevé détecté : ", DoubleToString(dd, 1), "% - Réduction du risque recommandée");
    }
}

//+------------------------------------------------------------------+
//| Calcul & optimisation des performances                          |
//+------------------------------------------------------------------+
void CalculateStrategyPerformance() {
    // Reset
    for(int j = 0; j < STRATEGY_COUNT; j++) {
        strategyPerformance[j].wins = 0;
        strategyPerformance[j].losses = 0;
        strategyPerformance[j].totalTrades = 0;
        strategyPerformance[j].totalProfit = 0.0;
    }

    int deals = HistoryDealsTotal();
    for(int i = 0; i < deals; i++) {
        ulong tk = HistoryDealGetTicket(i);
        if(tk == 0) continue;
        string cmt = HistoryDealGetString(tk, DEAL_COMMENT);
        double prof = HistoryDealGetDouble(tk, DEAL_PROFIT);

        for(int j = 0; j < STRATEGY_COUNT; j++) {
            if(StringFind(cmt, EnumToString(strategyPerformance[j].strategy)) >= 0) {
                strategyPerformance[j].totalTrades++;
                if(prof > 0) strategyPerformance[j].wins++; else if(prof < 0) strategyPerformance[j].losses++;
                strategyPerformance[j].totalProfit += prof;
                break;
            }
        }
    }

    for(int j = 0; j < STRATEGY_COUNT; j++) {
        if(strategyPerformance[j].totalTrades > 0) {
            strategyPerformance[j].winRate = (double)strategyPerformance[j].wins / strategyPerformance[j].totalTrades * 100.0;
            strategyPerformance[j].profitFactor = (strategyPerformance[j].losses == 0) ? DBL_MAX : (double)strategyPerformance[j].wins / strategyPerformance[j].losses;
        }
    }
}

//+------------------------------------------------------------------+
//| Optimisation dynamique                                          |
//+------------------------------------------------------------------+
void DynamicOptimization() {
    if(DateOfDay(TimeCurrent()) == DateOfDay(lastOptimization))
        return;

    CalculateStrategyPerformance();

    for(int i = 0; i < STRATEGY_COUNT; i++) {
        if(strategyPerformance[i].totalTrades < MinTradesToDisable)
            continue;

        if(strategyPerformance[i].winRate < MinWinRateToDisable) {
            strategyPerformance[i].enabled = false;
            Print("⚠️ Strategy disabled : ", EnumToString(strategyPerformance[i].strategy));
        }
    }

    lastOptimization = TimeCurrent();
}

//+------------------------------------------------------------------+
//| FIN DU CODE - DIAMOND EA VER30 - CORRECTED                      |
//+------------------------------------------------------------------+