//+------------------------------------------------------------------+
//|                     SBS DIAMOND PRO Ver 22                      |
//|                  Multi-strategy Expert Advisor (EA)              |
//|                 Compatible with GOLD (Gold/XAUUSD)               |
//|                 Author: amirbs14 - github.com/amirbs14           |
//+------------------------------------------------------------------+

#property copyright "amirbs14"
#property link      "https://github.com/amirbs14"
#property version   "22.0"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Indicators\Trend.mqh>          // Pour MACD, EMA, etc.
#include <Indicators\Oscilators.mqh>     // Pour RSI
#include <Indicators\Volumes.mqh>        // Pour ATR
//#include <Indicators\Bands.mqh>          // Pour Bollinger Bands
#include <Graphics\Graphic.mqh>          // Pour le dashboard
#include <Generic\ArrayList.mqh>         // Pour les collections
//#include <Indicators\Math.mqh>           // Pour les calculs mathématiques
//#include <Indicators\BollingerBands.mqh> // Le nom correct pour Bollinger Bands
//#include <Indicators\MyBands.mqh>             // Ligne corrigée
// Supprimer l'include Math.mqh qui n'est pas nécessaire
#include <Arrays\ArrayObj.mqh>           // Pour la gestion des tableaux
#include <Generic\HashMap.mqh>           // Pour les collections avancées
#include <ChartObjects\ChartObjectsTxtControls.mqh>  // Pour les objets texte
#include <ChartObjects\ChartObjectsShapes.mqh>       // Pour les formes

// 3. Paramètres d'entrée (inputs)
input group "Risk Management"
//input double RiskPercent = 1.0;  // Risk per trade (%)
input double   MaxDailyLossPercent = 3.0;    // Max daily loss (% of balance)
input double   MaxLossPercent = 1.5;         // Max loss per trade (% of balance)
input int      MaxConsecutiveLosses = 5;     // Max consecutive losses before pause
input int      PauseAfterLosses = 3;         // Pause after X consecutive losses
input int      PauseDurationMinutes = 30;    // Pause duration in minutes
input int      MinMinutesBetweenTrades = 5;  // Min time between trades
input bool     EnableStrategyAutoManagement = true; // Auto strategy management
input bool     EnableSuperTrend = true;      // Enable SuperTrend strategy
input bool     EnableNotifications = true;   // Enable notifications

// Paramètres Checklist Strategy
input int      Checklist_MACD_Fast = 8;
input int      Checklist_MACD_Slow = 20;
input int      Checklist_MACD_Signal = 9;
input double   Checklist_RSI_Min = 30.0;
input double   Checklist_RSI_Max = 70.0;
input double   Checklist_ADX_Min = 25.0;

// Ajouter ces variables d'entrée dans la section des paramètres :
input int      MinTradesToDisable = 20;    // Min trades before disabling strategy
input double   MinWinRateToDisable = 40.0; // Min win rate (%) to keep strategy enabled
input int      ReEnableAfterHours = 24;    // Hours before re-enabling disabled strategy

//--- Constants

#define MAX_RETRIES 3
#define STRATEGY_COUNT 6
#define MAX_POSITIONS_PER_SYMBOL 3
#define MAX_SYMBOLS 20


//--- Panel colors and dashboard design
#define COLOR_PANEL_BG  clrGainsboro
#define COLOR_HEADER    clrOrange
#define COLOR_BTN_CLOSE clrRed

//--- Input parameters (expert settings)
input double    InitialLot        = 0.01;     // Initial lot size for trades
input double    MaxLot            = 5.0;      // Maximum allowed lot size
input double    RiskPercent       = 1.0;      // Risk per trade (% of balance)
input int       MagicNumber       = 20200520; // Unique magic number for orders
input int       Slippage          = 5;        // Max slippage (points)
input int       ATRPeriod         = 14;       // ATR period for volatility filter
input int       DashboardPosX     = 10;       // Dashboard X position (pixels)
input int       DashboardPosY     = 10;       // Dashboard Y position (pixels)
input int       DashboardWidth    = 420;      // Dashboard width (pixels)
input int       DashboardHeight   = 220;      // Dashboard height (pixels)
input bool      EnableSound       = true;     // Enable sound alerts

//--- Enums
enum ENUM_STRATEGY {
   STRAT_NONE = 0,
   STRAT_CHECKLIST = 1,
   STRAT_BREAKOUT_RANGE = 2,
   STRAT_PULLBACK_EMA = 3,
   STRAT_SUPERTREND = 4,
   STRAT_RETEST_SR = 5,
   STRAT_SCALPING = 6
};

//--- Structures
struct SStrategyPerformance {
   ENUM_STRATEGY strategy;
   int totalTrades;
   int wins;
   int losses;
   double totalProfit;
   double winRate;
   double profitFactor;
   bool enabled;
   datetime lastTradeTime;
   double weight;
};

struct STradeSignal {
   bool valid;
   bool isBuySignal;
   double price;
   double sl;
   double tp;
   ENUM_STRATEGY strategy;
   string comment;
};

struct SSymbolStats {
   string symbol;
   int totalTrades;
   int winTrades;
   int lossTrades;
   int todayTrades;
   int todayWins;
   int todayLosses;
   double spreadSum;
   int spreadCount;
   double spreadMax;
   double lastSpread;
};

//--- Strategy tracking structures
struct StrategyStats {
   string  Name;                // Strategy name
   bool    Enabled;             // Is this strategy enabled
   int     TotalTrades;         // Number of trades
   int     Wins;                // Number of winning trades
   int     Losses;              // Number of losing trades
   double  Profit;              // Total profit for this strategy
   double  WinRate;             // Win rate (%)
   color   StatusColor;         // Color for dashboard display
};

//--- Daily stats structure
struct DailyStats {
   datetime Day;
   double   Profit;
   int      Trades;
   double   MaxDrawdown;
};

//--- Global variables
double          g_LastEquity      = 0.0;      // Stores last equity value
double          g_LastBalance     = 0.0;      // Stores last balance value
double          g_ATRValue        = 0.0;      // Current ATR value
string          g_SymbolGold1     = "GOLD";   // Symbol name for GOLD (XM and others)
string          g_SymbolGold2     = "XAUUSD"; // Symbol name for GOLD (most brokers)
bool            g_IsGold          = false;    // True if trading GOLD

//--- Example array for strategies (expand as needed)
StrategyStats strategies[];
int strategies_total = 0;        // Will be set after init
DailyStats day_stats[];

//--- Timer and dashboard variables
long dashboard_handle = -1;      // Graphical panel handle
bool dashboard_needs_update = true;





//--- Global objects
CTrade trade;
CPositionInfo positionInfo;
CHistoryOrderInfo historyOrder;
CDealInfo dealInfo;
int macdHandle;
int rsiHandle;

datetime lastPerformanceSaveTime = 0;
const int PERFORMANCE_SAVE_INTERVAL = 3600; // Sauvegarde toutes les heures

SStrategyPerformance strategyPerformance[STRATEGY_COUNT];
SSymbolStats stats[MAX_SYMBOLS];
int symbolCount = 0;

datetime lastTradeTime = 0;
ulong lastTradeTicket = 0;

//--- Classes
class CRiskManager {
private:
   double maxDailyLossPercent;
   double maxLossPercent;
   int maxConsecutiveLosses;
   int pauseAfterLosses;
   int pauseDurationMinutes;
   int consecutiveLosses;
   datetime pauseUntil;
   
public:
   CRiskManager(double dailyLossPct, double lossPct, int maxConsLoss, int pauseLoss, int pauseMin) :
      maxDailyLossPercent(dailyLossPct),
      maxLossPercent(lossPct),
      maxConsecutiveLosses(maxConsLoss),
      pauseAfterLosses(pauseLoss),
      pauseDurationMinutes(pauseMin),
      consecutiveLosses(0),
      pauseUntil(0) {}
   
   bool IsTradeAllowed();
   void UpdateTradeResult(double profit);
   double CalculatePositionSize(double entry, double stopLoss);
   int GetOpenPositionsCount(string symbol);
}; // Fin de la classe

// ----------------- Définitions des méthodes -----------------

bool CRiskManager::IsTradeAllowed() {
   // Exemple de logique : pause après x pertes consécutives
   if(TimeCurrent() < pauseUntil) return false;
   if(consecutiveLosses >= maxConsecutiveLosses && maxConsecutiveLosses > 0) {
      pauseUntil = TimeCurrent() + pauseDurationMinutes * 60;
      consecutiveLosses = 0;
      return false;
   }
   return true;
}

void CRiskManager::UpdateTradeResult(double profit) {
   // Mise à jour des pertes consécutives
   if(profit < 0) consecutiveLosses++;
   else consecutiveLosses = 0;
}

double CRiskManager::CalculatePositionSize(double entry, double stopLoss) {
   // Calcul du lot en fonction du risque max par trade (exemple simple)
   double riskPerTrade = maxLossPercent / 100.0;
   double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   double riskAmount = accountBalance * riskPerTrade;
   double slPoints = MathAbs(stopLoss - entry);
   double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotSize = 0.0;

   if(slPoints > 0.0 && tickSize > 0.0 && tickValue > 0.0) {
      double pricePerLot = slPoints / tickSize * tickValue;
      if(pricePerLot > 0.0)
         lotSize = riskAmount / pricePerLot;
   }

   // Respect du volume minimum
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
   double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   lotSize = MathMax(minLot, lotSize);
   lotSize = MathMin(maxLot, lotSize);
   // Arrondir au pas du broker
   lotSize = MathFloor(lotSize / lotStep) * lotStep;
   return lotSize;
}

int CRiskManager::GetOpenPositionsCount(string symbol) {
   int count = 0;
   for(int i = 0; i < PositionsTotal(); i++) {
      if(PositionGetSymbol(i) == symbol)
         count++;
   }
   return count;
}
class CStrategyManager {
private:
   // adxHandle, bbHandle;
   //int emaHandle, ema200Handle, superTrendHandle;
   //int checklistMacdHandle;
   
   
public:
   int atrHandle;
   int adxHandle, bbHandle;
   int emaHandle, ema200Handle, superTrendHandle;
   int checklistMacdHandle;
   
   
   bool InitializeIndicators();
   bool CheckIndicators();
   bool DetectSuperTrendSignal(STradeSignal &signal);
   bool DetectSRRetestSignal(STradeSignal &signal);
   bool DetectBreakoutSignal(STradeSignal &signal);
   bool DetectPullbackEMASignal(STradeSignal &signal);
   bool DetectScalpingSignal(STradeSignal &signal);
   bool ChecklistStrategySignal(STradeSignal &signal);
};

class CTradeManager {
private:
   CRiskManager *riskManager;
   CTrade trade;
   
public:
   CTradeManager(CRiskManager *manager) : riskManager(manager) {
      trade.SetExpertMagicNumber(MagicNumber);
      trade.SetMarginMode();
      trade.SetTypeFillingBySymbol(_Symbol);
   }
   
   bool ExecuteTrade(const STradeSignal &signal);
   void ManagePositions();
   void UpdateTrailingStop();
   bool CanOpenNewPosition(string symbol);
   void PartialClose(ulong ticket, double percentage); // PATCH: Ajout pour sortie partielle
};


//+------------------------------------------------------------------+
//| CTradeManager::UpdateTrailingStop                               |
//+------------------------------------------------------------------+
void CTradeManager::UpdateTrailingStop() {
   // PATCH: Déjà intégré à ManagePositions (ATR trailing & breakeven)
}

// PATCH : Sortie partielle
void CTradeManager::PartialClose(ulong ticket, double percentage) {
   if(PositionSelectByTicket(ticket)) {
      double vol = PositionGetDouble(POSITION_VOLUME);
      double closeLots = MathMax(SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN), vol * percentage);
      trade.PositionClosePartial(ticket, closeLots);
   }
}

//--- Global instances
CRiskManager riskManager(MaxDailyLossPercent, MaxLossPercent, MaxConsecutiveLosses, PauseAfterLosses, PauseDurationMinutes);
CStrategyManager strategyManager;
CTradeManager tradeManager(&riskManager);

//+------------------------------------------------------------------+
//| Utility Functions                                               |
//+------------------------------------------------------------------+

//--- Calculate ATR (Average True Range) value for current symbol and timeframe
double GetATR(int period = 14) {
   int handle = iATR(_Symbol, _Period, period);
   if(handle == INVALID_HANDLE)
      return(0.0);
   double atr[];
   if(CopyBuffer(handle, 0, 0, 2, atr) < 1) {
      IndicatorRelease(handle);
      return(0.0);
   }
   IndicatorRelease(handle);
   return(atr[0]);
}

//--- Calculate dynamic lot size based on risk percentage and stop loss
double CalcDynamicLot(double riskPercent) {
   // Calculate free margin and risk per trade
   double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
   double riskMoney  = AccountInfoDouble(ACCOUNT_BALANCE) * riskPercent / 100.0;
   double stopLossPoints = 200; // Default stop loss in points (should be adapted per strategy)
   double tickValue   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
   double tickSize    = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
   double lotStep     = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
   double minLot      = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   double maxLot      = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

   // If ATR is available, use it as SL
   double atr = GetATR(ATRPeriod);
   if(atr > 0)
      stopLossPoints = atr * 2 / SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   double lot = riskMoney / (stopLossPoints * tickValue / SymbolInfoDouble(_Symbol, SYMBOL_POINT));
   lot = MathMax(minLot, lot);
   lot = MathMin(maxLot, lot);
   lot = MathFloor(lot / lotStep) * lotStep;
   return(lot);
}

//--- Utility: Get color depending on value and thresholds
color GetValueColor(double val, double good, double bad) {
   // Return green if >= good, red if <= bad, yellow otherwise
   if(val >= good)
      return(clrLime);
   if(val <= bad)
      return(clrRed);
   return(clrYellow);
}

//--- Utility: Format double with sign for dashboard
string FormatSigned(double value, int digits=2) {
   if(value >= 0.0)
      return("+" + DoubleToString(value, digits));
   return(DoubleToString(value, digits));
}

//--- Update strategies statistics (winrate, colors, etc.)
void RefreshStrategyStats() {
   for(int i=0; i<strategies_total; i++) {
      StrategyStats s = strategies[i];
      if(s.TotalTrades > 0)
         s.WinRate = 100.0 * s.Wins / s.TotalTrades;
      else
         s.WinRate = 0.0;
      if(!s.Enabled)
         s.StatusColor = clrSilver;
      else if(s.WinRate >= 60.0)
         s.StatusColor = clrDeepSkyBlue;
      else if(s.WinRate >= 50.0)
         s.StatusColor = clrLime;
      else if(s.WinRate >= 40.0)
         s.StatusColor = clrYellow;
      else
         s.StatusColor = clrRed;
   }
}

//--- Update daily statistics (profit, number of trades, max drawdown)
void UpdateDailyStats() {
   datetime today = DateOfDay(TimeCurrent());
   int idx = -1;
   for(int i=0; i<ArraySize(day_stats); i++) {
      if(day_stats[i].Day == today) {
         idx = i;
         break;
      }
   }
   if(idx == -1) {
      ArrayResize(day_stats, ArraySize(day_stats)+1);
      idx = ArraySize(day_stats)-1;
      day_stats[idx].Day = today;
      day_stats[idx].Profit = 0.0;
      day_stats[idx].Trades = 0;
      day_stats[idx].MaxDrawdown = 0.0;
   }
   // Logic to update today's stats will be implemented in trading section
}

//--- Utility: Get the day from datetime (at 00:00:00)
datetime DateOfDay(datetime t) {
   MqlDateTime str;
   TimeToStruct(t, str);
   str.hour = 0;
   str.min = 0;
   str.sec = 0;
   return(StructToTime(str));
}

//--- Utility: Check if symbol is GOLD ("Gold" or "XAUUSD")
bool IsGold() {
   return(StringFind(_Symbol, g_SymbolGold1) >= 0 || StringFind(_Symbol, g_SymbolGold2) >= 0);
}

//--- Placeholder for anomaly detection (to be filled in main logic)
// Returns true if an anomaly is detected (for full close)
bool DetectMarketAnomaly() {
   // PATCH: Ajout condition d'anomalie (ex: écart-type, spread, ATR spike, etc.)
   double spread = (SymbolInfoInteger(_Symbol, SYMBOL_SPREAD)) * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   if(spread > 10 * SymbolInfoDouble(_Symbol, SYMBOL_POINT)) // Example threshold
      return(true);
   // TODO: Ajouter filtre écart-type ici pour GBPJPY (voir patch)
   return(false);
}

// PATCH: Ajout de la fonction LogSignalDetails si manquante (pour debug)
void LogSignalDetails(const STradeSignal &signal, int macdHandle, int rsiHandle) {
   double macd[1], signalLine[1], rsi[1];
   if(CopyBuffer(macdHandle, MAIN_LINE, 0, 1, macd) == 1 && 
      CopyBuffer(macdHandle, SIGNAL_LINE, 0, 1, signalLine) == 1 &&
      CopyBuffer(rsiHandle, 0, 0, 1, rsi) == 1) {
      PrintFormat("Signal details - Type: %s, Price: %.5f, SL: %.5f, TP: %.5f, MACD: %.5f, Signal: %.5f, RSI: %.2f",
                 signal.isBuySignal ? "BUY" : "SELL",
                 signal.price,
                 signal.sl,
                 signal.tp,
                 macd[0],
                 signalLine[0],
                 rsi[0]);
   }
}

//+------------------------------------------------------------------+
//| CTradeManager implementation                                    |
//+------------------------------------------------------------------+
bool CTradeManager::CanOpenNewPosition(string symbol) {
   // Vérification du nombre de positions
   if(riskManager.GetOpenPositionsCount(symbol) >= MAX_POSITIONS_PER_SYMBOL) {
      Print("Max positions (", MAX_POSITIONS_PER_SYMBOL, ") reached for ", symbol);
      return false;
   }
   
   // Filtre temporel entre les trades
   if(TimeCurrent() - lastTradeTime < MinMinutesBetweenTrades * 60) {
      Print("Minimum time between trades not reached (", MinMinutesBetweenTrades, " minutes required)");
      return false;
   }
   
   // Pour USDJPY, assouplir légèrement les conditions de volatilité
   if(symbol == "USDJPY") {
      double spread = SymbolInfoInteger(symbol, SYMBOL_SPREAD) * _Point;
      if(spread > 30 * _Point) { // 3 pips max pour USDJPY
         Print("Spread too high for USDJPY: ", spread/_Point*10, " pips");
         return false;
      }
   }
   else if(!IsGoodVolatility()) {
      Print("Volatility conditions not met for ", symbol);
      return false;
   }
   
   return true;
}

bool CTradeManager::ExecuteTrade(const STradeSignal &signal) {
   if(!CanOpenNewPosition(_Symbol)) {
      Print("Cannot open new position - maximum positions (", MAX_POSITIONS_PER_SYMBOL, ") reached for ", _Symbol);
      return false;
   }

   double lots = riskManager.CalculatePositionSize(signal.price, signal.sl);
   if(lots <= 0) return false;

   LogSignalDetails(signal, macdHandle, rsiHandle);

   bool result = signal.isBuySignal ? 
                trade.Buy(lots, _Symbol, signal.price, signal.sl, signal.tp, signal.comment) :
                trade.Sell(lots, _Symbol, signal.price, signal.sl, signal.tp, signal.comment);

   if(result) {
      ulong deal_ticket = trade.ResultDeal();
      double profit = 0.0;

      if(deal_ticket > 0) {
         profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
      }

      riskManager.UpdateTradeResult(profit);
      
      // Notification seulement à l'ouverture comme demandé
      if(EnableNotifications) {
         string msg = StringFormat("New %s trade opened via %s. SL: %.5f TP: %.5f",
                                 signal.isBuySignal ? "BUY" : "SELL",
                                 EnumToString(signal.strategy),
                                 signal.sl,
                                 signal.tp);
         MySendNotification(msg);
      }
      return true;
   }
   
   Print("Trade execution failed. Error: ", GetLastError());
   return false;
}

//+------------------------------------------------------------------+
//| PATCH: Gestion dynamique post-trade (sorties partielles, trailing stop, BE)
//+------------------------------------------------------------------+
void CTradeManager::ManagePositions() {
   for(int i = (int)PositionsTotal()-1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic = (int)PositionGetInteger(POSITION_MAGIC);
         double entry = PositionGetDouble(POSITION_PRICE_OPEN);
         double tp = PositionGetDouble(POSITION_TP);
         double sl = PositionGetDouble(POSITION_SL);
         double volume = PositionGetDouble(POSITION_VOLUME);
         ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

         // PATCH 1 : Sortie partielle à +1R sur 50% du volume
         double stopDistance = MathAbs(entry - sl);
         double r = 0.0;
         if(type==POSITION_TYPE_BUY && stopDistance>0)
            r = (SymbolInfoDouble(_Symbol, SYMBOL_BID)-entry)/stopDistance;
         else if(type==POSITION_TYPE_SELL && stopDistance>0)
            r = (entry-SymbolInfoDouble(_Symbol, SYMBOL_ASK))/stopDistance;
         if(volume >= 0.2 && r >= 1.0) { // PATCH: 50% close à +1R
            PartialClose(ticket, 0.5);
         }

         // PATCH 6 : Trailing stop dynamique (ATR) et break-even
         double atr = iATR(_Symbol, _Period, ATRPeriod);
         double profit = PositionGetDouble(POSITION_PROFIT);
         if(type == POSITION_TYPE_BUY && profit > atr*100) {
            double newSL = SymbolInfoDouble(_Symbol, SYMBOL_BID) - atr*1.0;
            if(newSL>sl) trade.PositionModify(ticket, newSL, tp);
         }
         if(type == POSITION_TYPE_SELL && profit > atr*100) {
            double newSL = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + atr*1.0;
            if(newSL<sl) trade.PositionModify(ticket, newSL, tp);
         }
         // PATCH : break-even si +1.5ATR
         if(type == POSITION_TYPE_BUY && SymbolInfoDouble(_Symbol, SYMBOL_BID)-entry > atr*1.5 && sl < entry) {
            trade.PositionModify(ticket, entry, tp);
         }
         if(type == POSITION_TYPE_SELL && entry-SymbolInfoDouble(_Symbol, SYMBOL_ASK) > atr*1.5 && sl > entry) {
            trade.PositionModify(ticket, entry, tp);
         }
      }
   }
}



//+------------------------------------------------------------------+
//| CStrategyManager implementation                                 |
//+------------------------------------------------------------------+
bool CStrategyManager::InitializeIndicators() {
   // Standard MACD
   macdHandle = iMACD(_Symbol, _Period, 12, 26, 9, PRICE_CLOSE);
   if(macdHandle == INVALID_HANDLE) {
      Print("Failed to create MACD indicator: ", GetLastError());
      return false;
   }
   
   // Checklist-specific MACD
   checklistMacdHandle = iMACD(_Symbol, _Period, Checklist_MACD_Fast, Checklist_MACD_Slow, Checklist_MACD_Signal, PRICE_CLOSE);
   if(checklistMacdHandle == INVALID_HANDLE) {
      Print("Failed to create Checklist MACD indicator: ", GetLastError());
      return false;
   }
   
   // ADX
   adxHandle = iADX(_Symbol, _Period, 14);
   if(adxHandle == INVALID_HANDLE) {
      Print("Failed to create ADX indicator: ", GetLastError());
      return false;
   }
   
   // ATR
   atrHandle = iATR(_Symbol, _Period, 14);
   if(atrHandle == INVALID_HANDLE) {
      Print("Failed to create ATR indicator: ", GetLastError());
      return false;
   }
   
   // RSI
   rsiHandle = iRSI(_Symbol, _Period, 14, PRICE_CLOSE);
   if(rsiHandle == INVALID_HANDLE) {
      Print("Failed to create RSI indicator: ", GetLastError());
      return false;
   }
   
   // Bollinger Bands
   bbHandle = iBands(_Symbol, _Period, 20, 0, 2.0, PRICE_CLOSE);
   if(bbHandle == INVALID_HANDLE) {
      Print("Failed to create Bollinger Bands indicator: ", GetLastError());
      return false;
   }
   
   // EMA 20
   emaHandle = iMA(_Symbol, _Period, 20, 0, MODE_EMA, PRICE_CLOSE);
   if(emaHandle == INVALID_HANDLE) {
      Print("Failed to create EMA indicator: ", GetLastError());
      return false;
   }
   
   // EMA 200 pour filtre de tendance
   ema200Handle = iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE);
   if(ema200Handle == INVALID_HANDLE) {
      Print("Failed to create EMA200 indicator: ", GetLastError());
      return false;
   }
   
   // SuperTrend (custom indicator)
   if(EnableSuperTrend) {
      superTrendHandle = iCustom(_Symbol, _Period, "SuperTrend");
      if(superTrendHandle == INVALID_HANDLE) {
         Print("Warning: Failed to create SuperTrend indicator: ", GetLastError());
      }
   }
   
   return true;
}

bool CStrategyManager::CheckIndicators() {
   if(macdHandle == INVALID_HANDLE || 
      checklistMacdHandle == INVALID_HANDLE || 
      adxHandle == INVALID_HANDLE || 
      atrHandle == INVALID_HANDLE || 
      rsiHandle == INVALID_HANDLE || 
      bbHandle == INVALID_HANDLE || 
      emaHandle == INVALID_HANDLE || 
      ema200Handle == INVALID_HANDLE) {
      Print("One or more indicator handles are invalid");
      return false;
   }
   if(EnableSuperTrend && superTrendHandle == INVALID_HANDLE) {
      Print("SuperTrend indicator is enabled but handle is invalid");
      return false;
   }
   return true;
}

bool CStrategyManager::DetectSuperTrendSignal(STradeSignal &signal) {
    if(superTrendHandle == INVALID_HANDLE) {
        Print("SuperTrend handle invalid, cannot detect signal.");
        signal.valid = false;
        return false;
    }
    // On lit les valeurs de SuperTrend sur la dernière bougie clôturée et la précédente
    double supertrend[2];
    if(CopyBuffer(superTrendHandle, 0, 1, 2, supertrend) < 2) {
        Print("Failed to copy SuperTrend buffer: ", GetLastError());
        signal.valid = false;
        return false;
    }

    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ema200[2];
    if(CopyBuffer(ema200Handle, 0, 1, 2, ema200) < 2) {
        Print("Failed to copy EMA200 buffer: ", GetLastError());
        signal.valid = false;
        return false;
    }

    // Signal d'achat : SuperTrend croise sous le prix et tendance haussière EMA200
    if(supertrend[1] < price && ema200[1] < price) {
        signal.isBuySignal = true;
        signal.price = price;
        SetStopTp(signal, true); // Utilise la fonction de ton EA pour SL/TP
        signal.valid = true;
        signal.comment = "SuperTrend BUY";
        return true;
    }
    // Signal de vente : SuperTrend croise au-dessus du prix et tendance baissière EMA200
    if(supertrend[1] > price && ema200[1] > price) {
        signal.isBuySignal = false;
        signal.price = price;
        SetStopTp(signal, false);
        signal.valid = true;
        signal.comment = "SuperTrend SELL";
        return true;
    }
    // Sinon, pas de signal
    signal.valid = false;
    return false;
}

bool CStrategyManager::DetectSRRetestSignal(STradeSignal &signal) {
    double srLevels[50];
    int nbLevels = LoadSRLevels(srLevels);
    if(nbLevels == 0) {
        signal.valid = false;
        return false;
    }
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ema200[1];
    if(CopyBuffer(ema200Handle, 0, 0, 1, ema200) < 1) {
        Print("Failed to copy EMA200 buffer: ", GetLastError());
        signal.valid = false;
        return false;
    }
    double tolerance = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 20; // Tolérance de 2 pips (adapter si besoin)
    for(int i = 0; i < nbLevels; i++) {
        // Retest support (prix touche niveau S/R par le bas)
        if(MathAbs(price - srLevels[i]) < tolerance && price > ema200[0]) {
            signal.isBuySignal = true;
            signal.price = price;
            SetStopTp(signal, true);
            signal.valid = true;
            signal.comment = "SR Retest BUY";
            return true;
        }
        // Retest résistance (prix touche niveau S/R par le haut)
        if(MathAbs(price - srLevels[i]) < tolerance && price < ema200[0]) {
            signal.isBuySignal = false;
            signal.price = price;
            SetStopTp(signal, false);
            signal.valid = true;
            signal.comment = "SR Retest SELL";
            return true;
        }
    }
    signal.valid = false;
    return false;
}

bool CStrategyManager::DetectBreakoutSignal(STradeSignal &signal) {
    int rangeLookback = 20; // Nombre de bougies pour repérer le range, ajuste selon ta logique
    double highestHigh = iHigh(_Symbol, _Period, 1);
    double lowestLow = iLow(_Symbol, _Period, 1);

    // Recherche du range sur les N dernières bougies (hors bougie en cours)
    for(int i = 2; i <= rangeLookback+1; i++) {
        double high = iHigh(_Symbol, _Period, i);
        double low = iLow(_Symbol, _Period, i);
        if(high > highestHigh) highestHigh = high;
        if(low < lowestLow) lowestLow = low;
    }

    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ema200[1];
    if(CopyBuffer(ema200Handle, 0, 0, 1, ema200) < 1) {
        Print("Failed to copy EMA200 buffer: ", GetLastError());
        signal.valid = false;
        return false;
    }

    // Breakout haussier (cassure du plus haut, tendance EMA200 haussière)
    if(price > highestHigh && price > ema200[0]) {
        signal.isBuySignal = true;
        signal.price = price;
        SetStopTp(signal, true);
        signal.valid = true;
        signal.comment = "Breakout BUY";
        return true;
    }
    // Breakout baissier (cassure du plus bas, tendance EMA200 baissière)
    if(price < lowestLow && price < ema200[0]) {
        signal.isBuySignal = false;
        signal.price = price;
        SetStopTp(signal, false);
        signal.valid = true;
        signal.comment = "Breakout SELL";
        return true;
    }
    signal.valid = false;
    return false;
}

bool CStrategyManager::DetectPullbackEMASignal(STradeSignal &signal) {
    double ema20[2], ema200[2], rsi[2], adx[2];
    if(CopyBuffer(emaHandle, 0, 1, 2, ema20) < 2 ||
       CopyBuffer(ema200Handle, 0, 1, 2, ema200) < 2 ||
       CopyBuffer(rsiHandle, 0, 1, 2, rsi) < 2 ||
       CopyBuffer(adxHandle, 0, 1, 2, adx) < 2) {
        Print("Failed to copy indicator buffers: ", GetLastError());
        signal.valid = false;
        return false;
    }
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double tolerance = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 10; // 1 pip de tolérance

    // Pullback haussier : tendance EMA200 haussière, prix revient sur EMA20, rebond, ADX fort, RSI correct
    if(price > ema200[1] && MathAbs(price - ema20[1]) < tolerance && ema20[1] > ema200[1]) {
        double prevClose = iClose(_Symbol, _Period, 1);
        if(prevClose < ema20[1] && adx[1] > 20 && rsi[1] > 40) {
            signal.isBuySignal = true;
            signal.price = price;
            SetStopTp(signal, true);
            signal.valid = true;
            signal.comment = "Pullback EMA BUY (RSI/ADX OK)";
            return true;
        }
    }

    // Pullback baissier : tendance EMA200 baissière, prix revient sur EMA20, rejet, ADX fort, RSI correct
    if(price < ema200[1] && MathAbs(price - ema20[1]) < tolerance && ema20[1] < ema200[1]) {
        double prevClose = iClose(_Symbol, _Period, 1);
        if(prevClose > ema20[1] && adx[1] > 20 && rsi[1] < 60) {
            signal.isBuySignal = false;
            signal.price = price;
            SetStopTp(signal, false);
            signal.valid = true;
            signal.comment = "Pullback EMA SELL (RSI/ADX OK)";
            return true;
        }
    }
    signal.valid = false;
    return false;
}

bool CStrategyManager::DetectScalpingSignal(STradeSignal &signal) {
    double ema20[2], ema200[2], rsi[2], adx[2], atr[1];
    if(CopyBuffer(emaHandle, 0, 1, 2, ema20) < 2 ||
       CopyBuffer(ema200Handle, 0, 1, 2, ema200) < 2 ||
       CopyBuffer(rsiHandle, 0, 1, 2, rsi) < 2 ||
       CopyBuffer(adxHandle, 0, 1, 2, adx) < 2 ||
       CopyBuffer(atrHandle, 0, 0, 1, atr) < 1) {
        Print("Failed to copy indicator buffers: ", GetLastError());
        signal.valid = false;
        return false;
    }

    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    double minATR = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 8;   // Volatilité mini (à ajuster)
    double maxSpread = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 12; // Spread max toléré (à ajuster)
    double minADX = 18; // Filtre pour éviter les marchés plats
    double minMicroPullback = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 2; // 0.2 pip de marge mini

    // Si tu utilises le volume, décommente ci-dessous (et crée le handle volume dans ton EA)
    // double tickVolume[2];
    // if(CopyBuffer(volumeHandle, 0, 1, 2, tickVolume) < 2) { ... }
    // double minVolume = 100; // À ajuster selon le symbole

    // Scalping HAUSSIER
    if(
        ema20[1] > ema200[1] &&               // Tendance haussière
        price > ema20[1] &&                   // Prix au-dessus EMA20
        rsi[1] > 35 && rsi[1] < 65 &&         // RSI neutre (pas suracheté)
        adx[1] > minADX &&                    // Marché directionnel
        atr[0] > minATR &&                    // Volatilité OK
        spread < maxSpread &&                 // Spread correct
        (price - ema20[1]) < minMicroPullback // Pas trop éloigné de l'EMA20 (évite de payer le sommet)
        // && tickVolume[1] > minVolume       // Si tu veux filtrer par volume
    ) {
        signal.isBuySignal = true;
        signal.price = price;
        SetStopTp(signal, true);
        signal.valid = true;
        signal.comment = "Scalping BUY (EMA/RSI/ADX/ATR/SPREAD)";
        return true;
    }

    // Scalping BAISSIER
    if(
        ema20[1] < ema200[1] &&               // Tendance baissière
        price < ema20[1] &&                   // Prix sous EMA20
        rsi[1] > 35 && rsi[1] < 65 &&         // RSI neutre (pas survendu)
        adx[1] > minADX &&
        atr[0] > minATR &&
        spread < maxSpread &&
        (ema20[1] - price) < minMicroPullback
        // && tickVolume[1] > minVolume
    ) {
        signal.isBuySignal = false;
        signal.price = price;
        SetStopTp(signal, false);
        signal.valid = true;
        signal.comment = "Scalping SELL (EMA/RSI/ADX/ATR/SPREAD)";
        return true;
    }

    signal.valid = false;
    return false;
}


// PATCH : Le reste des stratégies et signaux restent inchangés
// ... (reprends la logique signal/détection, validation, dashboard, etc. de ton code source)

//+------------------------------------------------------------------+
//| (Suite du code original ici, inchangé sauf pour les ajouts PATCH)
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| Check volatility conditions                                     |
//+------------------------------------------------------------------+
bool IsGoodVolatility() 
{
   double atr = iATR(_Symbol, _Period, 14);
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;

   double atrThreshold, spreadThreshold;
   if(_Symbol=="USDJPY") {
      atrThreshold = 0.15; // suggestion : abaisse à 0.15 (M30)
      spreadThreshold = 40 * _Point; // 4 pips
   } else {
      atrThreshold = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE) * 30;
      spreadThreshold = 15 * _Point; // 1.5 pips
   }
   bool volatilityOk = (atr > atrThreshold);
   bool spreadOk = (spread < spreadThreshold);

   if(!volatilityOk) PrintFormat("ATR %.5f < seuil %.5f", atr, atrThreshold);
   if(!spreadOk) PrintFormat("Spread %.1f pips > seuil %.1f", spread/_Point*10, spreadThreshold/_Point*10);

   return (volatilityOk && spreadOk);
}

//+------------------------------------------------------------------+
//| Update strategy weights based on performance                    |
//+------------------------------------------------------------------+
void UpdateStrategyWeights()
{
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].totalTrades < 5) continue;
      
      double recentWinRate = strategyPerformance[i].wins / (double)MathMax(20, strategyPerformance[i].totalTrades) * 100.0;
      double mediumWinRate = strategyPerformance[i].wins / (double)MathMax(100, strategyPerformance[i].totalTrades) * 100.0;
      
      double atr = iATR(_Symbol, _Period, 14);
      double volatilityFactor = (atr > 0.0005) ? 1.2 : (atr < 0.0002) ? 0.8 : 1.0;
      
      strategyPerformance[i].weight = recentWinRate * 0.5 + mediumWinRate * 0.3 + volatilityFactor * 0.2;
   }
}

//+------------------------------------------------------------------+
//| Strategy Performance Management                                 |
//+------------------------------------------------------------------+
void AutoManageStrategies()
{
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].totalTrades < MinTradesToDisable) continue;
      
      strategyPerformance[i].winRate = (double)strategyPerformance[i].wins / strategyPerformance[i].totalTrades * 100.0;
      
      if(strategyPerformance[i].winRate < MinWinRateToDisable) {
         strategyPerformance[i].enabled = false;
         strategyPerformance[i].lastTradeTime = TimeCurrent();
         if(EnableNotifications) {
            MySendNotification("Strategy Disabled: " + EnumToString(strategyPerformance[i].strategy) + 
                            " (Win Rate: " + DoubleToString(strategyPerformance[i].winRate, 1) + "%)");
         }
      }
      
      if(!strategyPerformance[i].enabled && 
         TimeCurrent() - strategyPerformance[i].lastTradeTime > ReEnableAfterHours * 3600) {
         strategyPerformance[i].enabled = true;
         if(EnableNotifications) {
            MySendNotification("Strategy Re-enabled: " + EnumToString(strategyPerformance[i].strategy));
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Load Support/Resistance Levels                                  |
//+------------------------------------------------------------------+
int LoadSRLevels(double &levels[])
{
   ArrayResize(levels, 0);
   int lookback = 100;
   int bars = (int)Bars(_Symbol, _Period);
   if(bars < lookback) lookback = bars;
   
   for(int i = 3; i < lookback-3; i++) {
      double high1 = iHigh(_Symbol, _Period, i+1);
      double high2 = iHigh(_Symbol, _Period, i);
      double high3 = iHigh(_Symbol, _Period, i-1);
      
      if(high2 > high1 && high2 > high3) {
         ArrayResize(levels, ArraySize(levels)+1);
         levels[ArraySize(levels)-1] = high2;
      }
      
      double low1 = iLow(_Symbol, _Period, i+1);
      double low2 = iLow(_Symbol, _Period, i);
      double low3 = iLow(_Symbol, _Period, i-1);
      
      if(low2 < low1 && low2 < low3) {
         ArrayResize(levels, ArraySize(levels)+1);
         levels[ArraySize(levels)-1] = low2;
      }
   }
   
   for(int i = 0; i < ArraySize(levels); i++) {
      for(int j = i+1; j < ArraySize(levels); j++) {
         if(MathAbs(levels[i] - levels[j]) < 10*_Point) {
            levels[i] = (levels[i] + levels[j]) / 2;
            for(int k = j; k < ArraySize(levels)-1; k++) {
               levels[k] = levels[k+1];
            }
            ArrayResize(levels, ArraySize(levels)-1);
            j--;
         }
      }
   }
   
   return ArraySize(levels);
}

void LoadStrategyPerformance() {
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      string prefix = "STRAT_" + EnumToString(strategyPerformance[i].strategy) + "_";
      strategyPerformance[i].wins = (int)GlobalVariableGet(prefix + "WINS");
      strategyPerformance[i].losses = (int)GlobalVariableGet(prefix + "LOSSES");
      strategyPerformance[i].totalTrades = (int)GlobalVariableGet(prefix + "TOTAL");
      strategyPerformance[i].totalProfit = GlobalVariableGet(prefix + "PROFIT");
      strategyPerformance[i].lastTradeTime = (datetime)GlobalVariableGet(prefix + "LAST_TIME");
   }
}

void SaveStrategyPerformance() {
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      string prefix = "STRAT_" + EnumToString(strategyPerformance[i].strategy) + "_";
      GlobalVariableSet(prefix + "WINS", strategyPerformance[i].wins);
      GlobalVariableSet(prefix + "LOSSES", strategyPerformance[i].losses);
      GlobalVariableSet(prefix + "TOTAL", strategyPerformance[i].totalTrades);
      GlobalVariableSet(prefix + "PROFIT", strategyPerformance[i].totalProfit);
      GlobalVariableSet(prefix + "LAST_TIME", (double)strategyPerformance[i].lastTradeTime);
   }
}

bool VerifyIndicators() {
   double macd[1], rsi[1], atr[1];
   return (CopyBuffer(macdHandle, MAIN_LINE, 0, 1, macd) == 1 && 
           CopyBuffer(rsiHandle, 0, 0, 1, rsi) == 1 && 
           CopyBuffer(strategyManager.atrHandle, 0, 0, 1, atr) == 1);
}

// PATCH : Ratio TP/SL corrigé ici (Patch point 2)
//+------------------------------------------------------------------+
//| SetStopTp : Ratio TP/SL amélioré (TP = 3x SL ou 2x SL selon besoin) |
//+------------------------------------------------------------------+
void SetStopTp(STradeSignal &signal, bool isBuy) {
   double atr = iATR(_Symbol, _Period, 14);
   double stopDistance = atr * 1.5;
   double maxStop = (_Symbol=="USDJPY") ? 0.5 : 0.01;
   double minStop = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;
   
   if(stopDistance < minStop) stopDistance = minStop;
   if(stopDistance > maxStop) stopDistance = maxStop;
   
   // PATCH: ratio TP/SL plus robuste
   double ratio = 3.0; // PATCH: 1:3 par défaut (modifie ici si tu veux 1:2)
   if(isBuy) {
      signal.sl = signal.price - stopDistance;
      signal.tp = signal.price + stopDistance * ratio;
   } else {
      signal.sl = signal.price + stopDistance;
      signal.tp = signal.price - stopDistance * ratio;
   }
}

bool OpenTrade(const STradeSignal &signal) {
   if(!signal.valid) return false;
   if(!ValidateTrade(signal)) return false;
   return tradeManager.ExecuteTrade(signal);
}

bool ValidateTrade(const STradeSignal &signal) {
   if(!signal.valid) return false;
   
   double spread = SymbolInfoDouble(_Symbol, SYMBOL_ASK) - SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double minStop = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL) * _Point;
   
   if((signal.isBuySignal && (signal.sl >= signal.price || signal.tp <= signal.price)) ||
      (!signal.isBuySignal && (signal.sl <= signal.price || signal.tp >= signal.price))) {
      return false;
   }
   
   return (spread < (_Symbol=="USDJPY" ? 0.02 : 0.0015));
}

void MySendNotification(string message) {
   if(!EnableNotifications) return;
   Alert(_Symbol + " " + EnumToString(_Period) + ": " + message);
   if(EnableSound) PlaySound("alert.wav");
}

void InitializeStrategies() {
   strategies_total = 0;
   ArrayResize(strategies, STRATEGY_COUNT);

   for(int i = 0; i < STRATEGY_COUNT; i++) {
      StrategyStats s;
      s.Enabled = true;
      s.TotalTrades = 0;
      s.Wins = 0;
      s.Losses = 0;
      s.Profit = 0.0;
      s.WinRate = 0.0;
      s.StatusColor = clrSilver;

      switch(i + 1) {
         case STRAT_CHECKLIST:
            s.Name = "Checklist";
            s.StatusColor = clrLime;
            break;
         case STRAT_BREAKOUT_RANGE:
            s.Name = "Breakout";
            s.StatusColor = clrGold;
            break;
         case STRAT_PULLBACK_EMA:
            s.Name = "Pullback EMA";
            s.StatusColor = clrOrange;
            break;
         case STRAT_SUPERTREND:
            s.Name = "SuperTrend";
            s.StatusColor = clrDeepSkyBlue;
            break;
         case STRAT_RETEST_SR:
            s.Name = "Retest SR";
            s.StatusColor = clrDodgerBlue;
            break;
         case STRAT_SCALPING:
            s.Name = "Scalping";
            s.StatusColor = clrViolet;
            break;
      }

      strategies[strategies_total++] = s;
   }

   RefreshStrategyStats();
}


bool CheckTradingConditions(STradeSignal &signal) {
   if(!strategyManager.CheckIndicators()) return false;
   if(!riskManager.IsTradeAllowed()) return false;

   // Créer un tableau temporaire des stratégies triées par poids
   int indices[STRATEGY_COUNT];
   for(int i = 0; i < STRATEGY_COUNT; i++)
      indices[i] = i;

   // Tri décroissant selon le poids
   for(int i = 0; i < STRATEGY_COUNT - 1; i++) {
      for(int j = i + 1; j < STRATEGY_COUNT; j++) {
         if(strategyPerformance[indices[j]].weight > strategyPerformance[indices[i]].weight) {
            int temp = indices[i];
            indices[i] = indices[j];
            indices[j] = temp;
         }
      }
   }

   // Parcourir les stratégies activées selon l’ordre trié
   for(int k = 0; k < STRATEGY_COUNT; k++) {
      int i = indices[k];
      if(!strategyPerformance[i].enabled)
         continue;

      ENUM_STRATEGY strat = strategyPerformance[i].strategy;

      switch(strat) {
         case STRAT_CHECKLIST:
            if(strategyManager.ChecklistStrategySignal(signal)) {
               signal.strategy = strat;
               signal.valid = true;
               return true;
            }
            break;

         case STRAT_SUPERTREND:
            if(strategyManager.DetectSuperTrendSignal(signal)) {
               signal.strategy = strat;
               signal.valid = true;
               return true;
            }
            break;

         case STRAT_BREAKOUT_RANGE:
            if(strategyManager.DetectBreakoutSignal(signal)) {
               signal.strategy = strat;
               signal.valid = true;
               return true;
            }
            break;

         case STRAT_PULLBACK_EMA:
            if(strategyManager.DetectPullbackEMASignal(signal)) {
               signal.strategy = strat;
               signal.valid = true;
               return true;
            }
            break;

         case STRAT_RETEST_SR:
            if(strategyManager.DetectSRRetestSignal(signal)) {
               signal.strategy = strat;
               signal.valid = true;
               return true;
            }
            break;

         case STRAT_SCALPING:
            if(strategyManager.DetectScalpingSignal(signal)) {
               signal.strategy = strat;
               signal.valid = true;
               return true;
            }
            break;
      }
   }

   signal.valid = false;
   return false;
}


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   // Vérification des paires autorisées
   string allowedSymbols[] = {"EURUSD", "USDJPY", "EURGBP", "USDGBP", "USDCAD", 
                             "AUDCAD", "AUDUSD", "GBPUSD", "USDCHF", "XAUUSD", "GOLD", "BTCUSD"};
   bool symbolAllowed = false;
   for(int i=0; i<ArraySize(allowedSymbols); i++) {
      if(_Symbol == allowedSymbols[i]) {
         symbolAllowed = true;
         break;
      }
   }
   
   if(!symbolAllowed) {
      Alert("EA DIAMOND v17.1 can't Trade this Pair/Symbol ", _Symbol);
      return INIT_FAILED;
   }

   // Initialize global variables
   InitGlobalVars();
   CheckGoldSymbol();

   // Initialize strategies performance tracking
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      strategyPerformance[i].strategy = (ENUM_STRATEGY)(i+1);
      strategyPerformance[i].enabled = true;
      strategyPerformance[i].weight = 1.0;
   }
   
   // Create indicator handles
   if(!strategyManager.InitializeIndicators()) {
      Print("Failed to initialize indicators!");
      return INIT_FAILED;
   }
   
   // Verify indicators
   if(!strategyManager.CheckIndicators()) {
      Print("Indicator check failed!");
      return INIT_FAILED;
   }
   
   // Initialize strategies
   InitializeStrategies();
   
   // Load historical performance data
   LoadStrategyPerformance();
   
   // Set up timer for periodic updates
   EventSetTimer(10);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   // Save strategy performance data
   SaveStrategyPerformance();
   DeleteDashboard();
   ObjectsDeleteAll(0, "Dashboard_");
   EventKillTimer();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   static datetime lastCheck = 0;
   // Vérifier les indicateurs toutes les 15 minutes
   if(TimeCurrent() - lastCheck >= 300) {
      if(!VerifyIndicators()) {
         Print("Indicator check failed in OnTick()!");
      }
      lastCheck = TimeCurrent();
   }

   // Update ATR and check gold status
   g_ATRValue = GetATR(ATRPeriod);
   g_IsGold = IsGold();

   // PATCH: Intelligence de sortie dynamique (sortie totale si anomalie ou profit/drawdown)
   CheckIntelligentExit();

   if(!tradeManager.CanOpenNewPosition(_Symbol)) {
      return;
   }
   
   STradeSignal signal;
   if(CheckTradingConditions(signal)) {
      OpenTrade(signal);
   }
   
   tradeManager.ManagePositions();
   tradeManager.UpdateTrailingStop();
   
   // Dashboard update
   if(dashboard_needs_update) {
      UpdateDashboard();
      dashboard_needs_update = false;
   }
}

//+------------------------------------------------------------------+
//| Timer function                                                   |
//+------------------------------------------------------------------+
void OnTimer()
{
   if(EnableStrategyAutoManagement) {
      AutoManageStrategies();
   }
   
   UpdateStrategyWeights();
   UpdateDashboard();
}

//+------------------------------------------------------------------+
//| Initialize global variables and structures                       |
//+------------------------------------------------------------------+
void InitGlobalVars()
{
   g_LastEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
   g_LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   g_ATRValue    = 0.0;
   dashboard_handle = -1;
   dashboard_needs_update = true;
}

//+------------------------------------------------------------------+
//| Detect if current symbol is GOLD (Gold or XAUUSD)                |
//+------------------------------------------------------------------+
void CheckGoldSymbol()
{
   g_IsGold = (StringFind(_Symbol, g_SymbolGold1) >= 0 || StringFind(_Symbol, g_SymbolGold2) >= 0);
}

//+------------------------------------------------------------------+
//| Function to close all open positions for this EA and symbol      |
//+------------------------------------------------------------------+
void PerformFullClose()
{
   int total = PositionsTotal();
   for(int i = total - 1; i >= 0; i--) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);
         if((pos_symbol == _Symbol) && (pos_magic == MagicNumber)) {
            double volume = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            if(type == POSITION_TYPE_BUY) {
            double volume = PositionGetDouble(POSITION_VOLUME);
            trade.PositionClose(ticket); // Au lieu de trade.PositionClose(ticket, volume, ...)
            }
            else if(type == POSITION_TYPE_SELL) {
               trade.PositionClose(ticket); // Au lieu de trade.PositionClose(ticket, volume, ...)
            }
         }
      }
   }
}

//+------------------------------------------------------------------+
//| PATCH : Sortie intelligente (profit, perte, anomalie)            |
//+------------------------------------------------------------------+
void CheckIntelligentExit()
{
   double totalProfit = 0.0;
   int openPositions = 0;
   int total = PositionsTotal();
   for(int i = 0; i < total; i++) {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket)) {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);
         if((pos_symbol == _Symbol) && (pos_magic == MagicNumber)) {
            totalProfit += PositionGetDouble(POSITION_PROFIT);
            openPositions++;
         }
      }
   }
   
   // PATCH : Seuils de sortie globale (à ajuster selon ton risque)
   double profitThreshold = 50.0;  // e.g. $50
   double lossThreshold   = -30.0; // e.g. -$30
   
   // PATCH : Détection d'anomalie
   bool anomaly = DetectMarketAnomaly();

   if(openPositions > 0) {
      // Full close on profit or loss threshold, or on anomaly
      if(totalProfit >= profitThreshold || totalProfit <= lossThreshold || anomaly) {
         Print("Full close triggered: total profit=", totalProfit, ", anomaly=", anomaly);
         PerformFullClose();
      }
   }
}

/////////////////////////////////////////////
// Dashboard PRO inspiré des EA commerciaux
/////////////////////////////////////////////

void UpdateDashboard()
{
   DeleteDashboard();

   // Panneau totalement opaque, gris foncé
   ObjectCreate(0, "DASHBOARD_PANEL", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XDISTANCE, DashboardPosX);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YDISTANCE, DashboardPosY);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XSIZE, DashboardWidth);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YSIZE, DashboardHeight);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_CORNER, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_COLOR, C'30,30,30'); // Opaque, gris foncé
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_BACK, true);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_SELECTABLE, false);

   int y = DashboardPosY + 12; // Premier y

   // Titre
   string objName = "DASHBOARD_HEADER";
   ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + 15);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, clrGold);
   ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, 12);
   ObjectSetString(0, objName, OBJPROP_TEXT, "★ SBS DIAMOND PRO Ver 22 ★");

   y += 25; // Espace après le titre

   // Infos verticales, police 11, bien espacées
   int fontSize = 11;
   string infos[8];
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   double freeMargin = AccountInfoDouble(ACCOUNT_MARGIN_FREE);
   double profitOpen = AccountInfoDouble(ACCOUNT_PROFIT);
   int totalTrades = 0, tradesWin = 0, tradesLoss = 0;
   double maxDrawdown = CalculateMaxDrawdown();

   // Historique (exemple simple)
   int deals = HistoryDealsTotal();
   for(int i=0; i<deals; i++) {
      ulong ticket = HistoryDealGetTicket(i);
      double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
      if(profit > 0) tradesWin++;
      else if(profit < 0) tradesLoss++;
      totalTrades++;
   }

   infos[0] = "Balance         : " + DoubleToString(balance,2);
   infos[1] = "Equity          : " + DoubleToString(equity,2);
   infos[2] = "Free Margin     : " + DoubleToString(freeMargin,2);
   infos[3] = "Profit en cours : " + DoubleToString(profitOpen,2);
   infos[4] = "Trades          : " + IntegerToString(totalTrades);
   infos[5] = "Gagnants        : " + IntegerToString(tradesWin);
   infos[6] = "Perdants        : " + IntegerToString(tradesLoss);
   infos[7] = "Max Drawdown    : " + DoubleToString(maxDrawdown,2);

   for(int i=0; i<ArraySize(infos); i++)
   {
      objName = "DASHBOARD_INFO_" + IntegerToString(i);
      ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + 15);
      ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
      // Couleurs par type
      color c = clrWhite;
      if(i==5) c = clrLime; // Gagnants
      if(i==6) c = clrRed;  // Perdants
      if(i==7) c = clrOrangeRed; // DD
      ObjectSetInteger(0, objName, OBJPROP_COLOR, c);
      ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, fontSize);
      ObjectSetString(0, objName, OBJPROP_TEXT, infos[i]);
      y += 20;
   }

   // Section stratégies (une par ligne)
   y += 10; // espace
   for(int i=0; i<strategies_total; i++) {
      string objNameStrat = "DASHBOARD_STRAT_" + IntegerToString(i);
      StrategyStats s = strategies[i];
      string txt = "▶ " + s.Name +
         " | Trades: " + IntegerToString(s.TotalTrades) +
         " | WinRate: " + DoubleToString(s.WinRate,1) + "%" +
         " | Profit: " + FormatSigned(s.Profit, 2);

      ObjectCreate(0, objNameStrat, OBJ_LABEL, 0, 0, 0);
      ObjectSetInteger(0, objNameStrat, OBJPROP_XDISTANCE, DashboardPosX + 15);
      ObjectSetInteger(0, objNameStrat, OBJPROP_YDISTANCE, y);
      ObjectSetInteger(0, objNameStrat, OBJPROP_COLOR, s.StatusColor);
      ObjectSetInteger(0, objNameStrat, OBJPROP_FONTSIZE, fontSize);
      ObjectSetString(0, objNameStrat, OBJPROP_TEXT, txt);
      y += 20;
   }

   // Section stats du jour
y += 10; // espace

objName = "DASHBOARD_DAILY";
ObjectCreate(0, objName, OBJ_LABEL, 0, 0, 0);
ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + 15);
ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, y);
ObjectSetInteger(0, objName, OBJPROP_COLOR, clrAqua);
ObjectSetInteger(0, objName, OBJPROP_FONTSIZE, fontSize);

string txt = "";
if(ArraySize(day_stats) > 0)
{
   int last = ArraySize(day_stats) - 1;
   txt = StringFormat(
      "Aujourd'hui : Trades %d   Profit: %s   Max DD: %.2f",
      day_stats[last].Trades,
      FormatSigned(day_stats[last].Profit,2),
      day_stats[last].MaxDrawdown
   );
}
else
{
   txt = "Aujourd'hui : Aucune donnée";
}

//////////// BOUTON de fermeture /////////////////

ObjectSetString(0, objName, OBJPROP_TEXT, txt);
   // Bouton fermer
   objName = "DASHBOARD_CLOSE";
   ObjectCreate(0, objName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, objName, OBJPROP_XDISTANCE, DashboardPosX + DashboardWidth - 38);
   ObjectSetInteger(0, objName, OBJPROP_YDISTANCE, DashboardPosY + 8);
   ObjectSetInteger(0, objName, OBJPROP_XSIZE, 30);
   ObjectSetInteger(0, objName, OBJPROP_YSIZE, 22);
   ObjectSetInteger(0, objName, OBJPROP_COLOR, C'255,60,60');
   ObjectSetInteger(0, objName, OBJPROP_BACK, false);

   string txtName = "DASHBOARD_CLOSE_TXT";
   ObjectCreate(0, txtName, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, txtName, OBJPROP_XDISTANCE, DashboardPosX + DashboardWidth - 33);
   ObjectSetInteger(0, txtName, OBJPROP_YDISTANCE, DashboardPosY + 12);
   ObjectSetInteger(0, txtName, OBJPROP_COLOR, clrWhite);
   ObjectSetInteger(0, txtName, OBJPROP_FONTSIZE, fontSize);
   ObjectSetString(0, txtName, OBJPROP_TEXT, "X");
}

void DeleteDashboard()
{
   ObjectDelete(0, "DASHBOARD_PANEL");
   ObjectDelete(0, "DASHBOARD_HEADER");
   for(int i=0; i<8; i++)
      ObjectDelete(0, "DASHBOARD_INFO_" + IntegerToString(i));
   for(int i=0; i<strategies_total; i++)
      ObjectDelete(0, "DASHBOARD_STRAT_" + IntegerToString(i));
   ObjectDelete(0, "DASHBOARD_DAILY");
   ObjectDelete(0, "DASHBOARD_CLOSE");
   ObjectDelete(0, "DASHBOARD_CLOSE_TXT");
}

// Utilitaire
//string FormatSigned(double val, int digits=2)
//{
 //  if(val>=0) return "+"+DoubleToString(val,digits);
//   return DoubleToString(val,digits);
//}

// Drawdown simplifié (à affiner selon ta logique)
double CalculateMaxDrawdown()
{
   double maxEquity = AccountInfoDouble(ACCOUNT_BALANCE);
   double minEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   double dd = maxEquity - minEquity;
   return dd;
}

// Fonction de gestion des événements graphiques (clics) Close BuTTON
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam)
{
    // Si on a cliqué sur un objet
    if(id == CHARTEVENT_OBJECT_CLICK)
    {
        if(sparam == "DASHBOARD_CLOSE")
        {
            ExpertRemove(); // Ferme l'EA
        }
    }
}
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+
//| End of DIAMOND PRO v20 PATCHED                                  |
//+------------------------------------------------------------------+  

