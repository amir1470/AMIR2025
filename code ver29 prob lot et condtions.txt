//+------------------------------------------------------------------+
//|                     DIAMOND EA VER26 - CORRECTED                 |
//|                  Multi-strategy Expert Advisor                   |
//|                 Compatible avec GOLD (Gold/XAUUSD)               |
//|                 Auteur: amirbs14 - github.com/amirbs14           |
//|                 Version corrigée et optimisée                    |
//+------------------------------------------------------------------+

//===================================================
// SECTION 1 : INCLUDES ET CONFIGURATION DE BASE
//===================================================

//--- Includes des bibliothèques MQL5
#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\HistoryOrderInfo.mqh>
#include <Trade\DealInfo.mqh>
#include <Indicators\Trend.mqh>
#include <Indicators\Oscilators.mqh>
#include <Indicators\Volumes.mqh>
#include <Generic\ArrayList.mqh>
#include <Arrays\ArrayObj.mqh>
#include <Generic\HashMap.mqh>
#include <ChartObjects\ChartObjectsTxtControls.mqh>
#include <ChartObjects\ChartObjectsShapes.mqh>
#include <Generic\HashSet.mqh>


//--- Définition des propriétés de l'EA
#property copyright "amirbs14"
#property link      "https://github.com/amirbs14"
#property version   "26.0"
#property strict

//===================================================
// SECTION 2 : CONSTANTES GLOBALES ET DEFINITIONS
//===================================================

#define STRATEGY_COUNT 6                // Nombre total de stratégies
#define MAX_POSITIONS_PER_SYMBOL 5     // Positions max par symbole
#define MAX_SYMBOLS 20                  // Symboles max suivis
#define MAX_RETRIES 5                   // Tentatives de lecture indicateurs
#define MIN_BARS_REQUIRED 100            // Barres minimum requises

//===================================================
// SECTION 3 : STRUCTURES DE DONNEES
//===================================================

//+------------------------------------------------------------------+
//| Enumération des stratégies disponibles                          |
//+------------------------------------------------------------------+
enum ENUM_STRATEGY {
   STRAT_NONE = 0,          // Aucune stratégie
   STRAT_CHECKLIST = 1,     // Stratégie checklist
   STRAT_BREAKOUT_RANGE = 2,// Stratégie breakout
   STRAT_PULLBACK_EMA = 3,  // Stratégie pullback EMA
   STRAT_SUPERTREND = 4,    // Stratégie SuperTrend
   STRAT_RETEST_SR = 5,     // Stratégie retest support/résistance
   STRAT_SCALPING = 6       // Stratégie scalping
};

//+------------------------------------------------------------------+
//| Structure pour les performances des stratégies                  |
//+------------------------------------------------------------------+
struct SStrategyPerformance {
   ENUM_STRATEGY strategy;     // Type de stratégie
   int totalTrades;            // Nombre total de trades
   int wins;                   // Trades gagnants
   int losses;                 // Trades perdants
   double totalProfit;         // Profit total
   double winRate;             // Taux de réussite
   double profitFactor;        // Facteur de profit
   bool enabled;               // Statut d'activation
   datetime lastTradeTime;     // Heure du dernier trade
   double weight;              // Poids dans la sélection
};

//+------------------------------------------------------------------+
//| Structure pour les signaux de trading                          |
//+------------------------------------------------------------------+
struct STradeSignal {
   bool valid;                 // Validité du signal
   bool isBuySignal;           // Signal d'achat si vrai
   double price;               // Prix d'entrée
   double sl;                  // Niveau de stop-loss
   double tp;                  // Niveau de take-profit
   ENUM_STRATEGY strategy;     // Stratégie générant le signal
   string comment;             // Commentaire descriptif
};

//+------------------------------------------------------------------+
//| Structure pour les statistiques par symbole                     |
//+------------------------------------------------------------------+
struct SSymbolStats {
   string symbol;              // Symbole du marché
   int totalTrades;            // Trades totaux
   int winTrades;              // Trades gagnants
   int lossTrades;             // Trades perdants
   int todayTrades;            // Trades aujourd'hui
   int todayWins;              // Gains aujourd'hui
   int todayLosses;            // Pertes aujourd'hui
   double spreadSum;           // Somme des spreads
   int spreadCount;            // Nombre de spreads enregistrés
   double spreadMax;           // Spread maximum observé
   double lastSpread;          // Dernier spread enregistré
};

//+------------------------------------------------------------------+
//| Structure pour les statistiques des stratégies                  |
//+------------------------------------------------------------------+
struct StrategyStats {
   string  Name;               // Nom de la stratégie
   bool    Enabled;            // Statut d'activation
   int     TotalTrades;        // Trades totaux
   int     Wins;               // Trades gagnants
   int     Losses;             // Trades perdants
   double  Profit;             // Profit total
   double  WinRate;            // Taux de réussite
   color   StatusColor;        // Couleur d'affichage
};

//+------------------------------------------------------------------+
//| Structure pour les statistiques quotidiennes                    |
//+------------------------------------------------------------------+
struct DailyStats {
   datetime Day;               // Date
   double   Profit;            // Profit du jour
   int      Trades;            // Nombre de trades
   double   MaxDrawdown;       // Drawdown maximum
};

//===================================================
// SECTION 4 : PARAMETRES D'ENTREE
//===================================================

input group "Risk Management"
input double   MaxDailyLossPercent = 5.0;    // Perte quotidienne max (% du balance)
input double   MaxLossPercent = 2.0;         // Perte max par trade (% du balance)
input int      MaxConsecutiveLosses = 10;     // Pertes consécutives max avant pause
input int      PauseAfterLosses = 10;         // Pause après X pertes consécutives
input int      PauseDurationMinutes = 30;    // Durée de pause en minutes
input int      MinMinutesBetweenTrades = 5;  // Temps minimum entre trades
input bool     EnableStrategyAutoManagement = true; // Gestion automatique des stratégies
input bool     EnableNotifications = true;   // Activer les notifications
input bool     EnableDebugLog = true;        // Activer les logs détaillés

input group "SuperTrend Settings"
input int      SuperTrend_ATRPeriod = 10;    // Période ATR pour SuperTrend
input double   SuperTrend_Multiplier = 3.0;  // Multiplicateur pour SuperTrend
input bool     EnableSuperTrendInput = true; // Activer la stratégie SuperTrend

input group "Checklist Strategy Parameters"
input int      Checklist_MACD_Fast = 8;      // Période rapide MACD
input int      Checklist_MACD_Slow = 20;     // Période lente MACD
input int      Checklist_MACD_Signal = 9;    // Période signal MACD
input double   Checklist_RSI_Min = 30.0;     // Niveau minimum RSI
input double   Checklist_RSI_Max = 70.0;     // Niveau maximum RSI
input double   Checklist_ADX_Min = 10.0;     // Niveau minimum ADX

input group "Additional Parameters"
input int      MinTradesToDisable = 20;      // Trades min avant désactivation
input double   MinWinRateToDisable = 40.0;   // Taux de réussite min (%)
input int      ReEnableAfterHours = 24;      // Heures avant réactivation
input double   MaxSpreadPips = 30.0;         // Tolérance max du spread en pips

input group "Trading Settings"
input double   RiskPercent = 0.5;            // Pourcentage de risque
input double   InitialLot = 0.01;            // Taille de lot initiale
input double   MaxLot = 0.5;                 // Taille de lot maximum
input int      MagicNumber = 20200520;       // Magic number unique
input int      Slippage = 1;                 // Slippage max (points)
input int      ATRPeriod = 14;               // Période ATR pour filtre volatilité

input group "Dashboard Settings"
input int      DashboardPosX = 10;           // Position X du dashboard (pixels)
input int      DashboardPosY = 10;           // Position Y du dashboard (pixels)
input int      DashboardWidth = 420;         // Largeur du dashboard (pixels)
input int      DashboardHeight = 220;        // Hauteur du dashboard (pixels)
input bool     EnableSound = true;           // Activer les alertes sonores

//===================================================
// SECTION 5 : VARIABLES GLOBALES
//===================================================
datetime lastOptimization = 0;
double          g_LastEquity      = 0.0;     // Dernière valeur d'equity
double          g_LastBalance     = 0.0;     // Dernière valeur de balance
double          g_ATRValue        = 0.0;     // Valeur ATR courante
string          g_SymbolGold1     = "GOLD";  // Premier symbole pour l'or
string          g_SymbolGold2     = "XAUUSDm";// Deuxième symbole pour l'or
bool            g_IsGold          = false;   // Si le symbole courant est l'or
bool            ea_is_active      = true;    // Statut d'activation de l'EA
bool            EnableSuperTrend  = true;    // Statut d'activation SuperTrend

// Tableaux pour le suivi des performances
StrategyStats strategies[];
int strategies_total = 0;
DailyStats day_stats[];

// Handles et objets globaux
CTrade trade;                               // Objet pour exécuter les trades
CPositionInfo positionInfo;                 // Information sur les positions
CHistoryOrderInfo historyOrder;             // Information historique
CDealInfo dealInfo;                         // Information sur les deals
int macdHandle;                             // Handle MACD
int rsiHandle;                              // Handle RSI

// Suivi du temps
datetime lastPerformanceSaveTime = 0;       // Dernière sauvegarde
const int PERFORMANCE_SAVE_INTERVAL = 3600; // Intervalle de sauvegarde (sec)

// Performances des stratégies
SStrategyPerformance strategyPerformance[STRATEGY_COUNT];
SSymbolStats stats[MAX_SYMBOLS];
int symbolCount = 0;

// Suivi des trades
datetime lastTradeTime = 0;                 // Heure du dernier trade
ulong lastTradeTicket = 0;                  // Ticket du dernier trade

//===================================================
// SECTION 6 : CLASSES PRINCIPALES
//===================================================

//+------------------------------------------------------------------+
//| Classe CRiskManager - Gestion avancée des risques               |
//+------------------------------------------------------------------+
class CRiskManager {
private:
   double maxDailyLossPercent;              // Perte quotidienne max (%)
   double maxLossPercent;                   // Perte max par trade (%)
   int maxConsecutiveLosses;                // Pertes consécutives max
   int pauseAfterLosses;                    // Pause après X pertes
   int pauseDurationMinutes;                // Durée de pause (minutes)
   int consecutiveLosses;                   // Compteur de pertes consécutives
   datetime pauseUntil;                     // Heure de fin de pause
   datetime lastTradeTime;                  // Heure du dernier trade

public:
   // Constructeur
   CRiskManager(double dailyLossPct, double lossPct, int maxConsLoss, int pauseLoss, int pauseMin) :
      maxDailyLossPercent(dailyLossPct),
      maxLossPercent(lossPct),
      maxConsecutiveLosses(maxConsLoss),
      pauseAfterLosses(pauseLoss),
      pauseDurationMinutes(pauseMin),
      consecutiveLosses(0),
      pauseUntil(0),
      lastTradeTime(0) {}

   // Vérifie si le trading est autorisé
   bool IsTradeAllowed() const {
      if (pauseUntil > TimeCurrent()) {
         Print("⛔ Pause de trading active jusqu'à ", TimeToString(pauseUntil, TIME_MINUTES));
         return false;
      }

      double balance = AccountInfoDouble(ACCOUNT_BALANCE);
      double equity = AccountInfoDouble(ACCOUNT_EQUITY);
      if (balance <= 0) return false;

      double dailyLoss = ((balance - equity) / balance) * 100.0;

      if (dailyLoss >= maxDailyLossPercent) {
         PrintFormat("❌ Limite de perte quotidienne dépassée: %.2f%% ≥ %.2f%%", dailyLoss, maxDailyLossPercent);
         return false;
      }

      if (consecutiveLosses >= maxConsecutiveLosses) {
         PrintFormat("❌ Limite de pertes consécutives atteinte: %d", consecutiveLosses);
         return false;
      }

      return true;
   }

   // Met à jour les résultats du trade
   void UpdateTradeResult(double profit) {
      if (profit < 0) {
         consecutiveLosses++;
         if (consecutiveLosses >= pauseAfterLosses) {
            pauseUntil = TimeCurrent() + pauseDurationMinutes * 60;
            PrintFormat("🚫 Pause de trading pour %d minutes après %d pertes", pauseDurationMinutes, consecutiveLosses);
         }
      } else {
         consecutiveLosses = 0;
      }
      lastTradeTime = TimeCurrent();
   }

   // Calcule la taille de la position
   double CalculatePositionSize(double entry, double stopLoss) const {
      if (entry <= 0 || stopLoss <= 0) {
         Print("❗ Prix ou SL invalide pour le calcul des lots");
         return 0.0;
      }

      double stopDistance = MathAbs(entry - stopLoss);
      if (stopDistance < _Point) {
         Print("❗ SL trop proche du prix d'entrée");
         return 0.0;
      }

      double riskAmount = AccountInfoDouble(ACCOUNT_BALANCE) * maxLossPercent / 100.0;

      double tickValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
      double tickSize = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
      double lotStep = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);

      if (tickValue == 0 || tickSize == 0 || lotStep == 0) {
         Print("❗ Information marché indisponible (taille/valeur du tick)");
         return 0.0;
      }

      double costPerLot = stopDistance / tickSize * tickValue;
      if (costPerLot <= 0) {
         Print("❗ Distance de stop ou valeurs de tick invalides");
         return 0.0;
      }

      double rawLots = riskAmount / costPerLot;
      double roundedLots = MathFloor(rawLots / lotStep) * lotStep;

      // Application des limites
      roundedLots = MathMax(minLot, MathMin(roundedLots, maxLot));

      if (roundedLots < minLot) {
         PrintFormat("❗ Taille de lot calculée %.2f en dessous du minimum %.2f", roundedLots, minLot);
         return 0.0;
      }

      return roundedLots;
   }

   // Compte les positions ouvertes
   int GetOpenPositionsCount(string symbol) const {
      int count = 0;
      for (int i = 0; i < PositionsTotal(); i++) {
         ulong ticket = PositionGetTicket(i);
         if (PositionSelectByTicket(ticket)) {
            string sym = PositionGetString(POSITION_SYMBOL);
            int magic = (int)PositionGetInteger(POSITION_MAGIC);
            if (sym == symbol && magic == MagicNumber) {
               count++;
            }
         }
      }
      return count;
   }

   // Vérifie le délai minimum entre les trades
   bool CheckMinTimeBetweenTrades(int minMinutes) const {
      if (lastTradeTime == 0) return true;
      return (TimeCurrent() - lastTradeTime) >= (minMinutes * 60);
   }

   // Réinitialise les pertes consécutives
   void ResetConsecutiveLosses() {
      consecutiveLosses = 0;
      pauseUntil = 0;
      Print("✅ Pertes consécutives réinitialisées");
   }
};

//+------------------------------------------------------------------+
//| Classe CStrategyManager - Gestion des stratégies et indicateurs |
//+------------------------------------------------------------------+
class CStrategyManager {
private:
   int macdHandle;                          // Handle MACD standard
   int rsiHandle;                           // Handle RSI
   int atrHandle;                           // Handle ATR
   int adxHandle, bbHandle;                 // Handles ADX et Bollinger Bands
   int emaHandle, ema200Handle;             // Handles EMA
   int superTrendHandle;                    // Handle SuperTrend
   int checklistMacdHandle;                 // Handle MACD pour la checklist

public:
   // Constructeur
   CStrategyManager() :
      macdHandle(INVALID_HANDLE),
      rsiHandle(INVALID_HANDLE),
      atrHandle(INVALID_HANDLE),
      adxHandle(INVALID_HANDLE),
      bbHandle(INVALID_HANDLE),
      emaHandle(INVALID_HANDLE),
      ema200Handle(INVALID_HANDLE),
      superTrendHandle(INVALID_HANDLE),
      checklistMacdHandle(INVALID_HANDLE) {}

   // Initialise tous les indicateurs
   bool InitializeIndicators() {
      ReleaseAllHandles();

      // Initialisation des indicateurs de base (obligatoires)
      if(!InitIndicatorWithRetry(macdHandle, iMACD(_Symbol, _Period, 12, 26, 9, PRICE_CLOSE), "MACD")) return false;
      if(!InitIndicatorWithRetry(checklistMacdHandle, iMACD(_Symbol, _Period, Checklist_MACD_Fast, Checklist_MACD_Slow, Checklist_MACD_Signal, PRICE_CLOSE), "Checklist MACD")) return false;
      if(!InitIndicatorWithRetry(adxHandle, iADX(_Symbol, _Period, 14), "ADX")) return false;
      if(!InitIndicatorWithRetry(atrHandle, iATR(_Symbol, _Period, 14), "ATR")) return false;
      if(!InitIndicatorWithRetry(rsiHandle, iRSI(_Symbol, _Period, 14, PRICE_CLOSE), "RSI")) return false;
      if(!InitIndicatorWithRetry(bbHandle, iBands(_Symbol, _Period, 20, 0, 2.0, PRICE_CLOSE), "Bollinger Bands")) return false;
      if(!InitIndicatorWithRetry(emaHandle, iMA(_Symbol, _Period, 20, 0, MODE_EMA, PRICE_CLOSE), "EMA20")) return false;
      if(!InitIndicatorWithRetry(ema200Handle, iMA(_Symbol, _Period, 200, 0, MODE_EMA, PRICE_CLOSE), "EMA200")) return false;

      // Initialisation conditionnelle du SuperTrend
      if(EnableSuperTrend) {
         superTrendHandle = iCustom(_Symbol, _Period, "SuperTrend", SuperTrend_ATRPeriod, SuperTrend_Multiplier);

         if(superTrendHandle == INVALID_HANDLE) {
            Print("❌ Erreur de chargement du SuperTrend : handle invalide");
            EnableSuperTrend = false;
         } else {
            Print("✅ SuperTrend handle OK : ", superTrendHandle);

            Sleep(500);  // petite pause pour laisser l'indicateur se charger

            double testBuffer[];
            ArrayResize(testBuffer, 1);
            int copied = CopyBuffer(superTrendHandle, 0, 0, 1, testBuffer);
            PrintFormat("🟡 SuperTrend CopyBuffer -> Copied: %d | Value: %.5f", copied, testBuffer[0]);

            // 👉 ICI la correction pour détecter DBL_MAX et valeurs aberrantes
            // Modifier la vérification SuperTrend (~ligne 1208)
if(copied <= 0 || ArraySize(testBuffer) < 1 || !MathIsValidNumber(testBuffer[0])) {
   Print("Erreur données SuperTrend - Code:", GetLastError());
   EnableSuperTrend = false;
   return false;
}
            else {
               Print("✅ SuperTrend initialisé avec une valeur = ", testBuffer[0]);
            }
         }
      }

      Print("✅ Tous les indicateurs initialisés avec succès");
      return AreIndicatorsReady();
   }

   // Vérifie l'état des indicateurs
   bool CheckIndicators() {
      if(macdHandle == INVALID_HANDLE || 
         checklistMacdHandle == INVALID_HANDLE || 
         adxHandle == INVALID_HANDLE || 
         atrHandle == INVALID_HANDLE || 
         rsiHandle == INVALID_HANDLE || 
         bbHandle == INVALID_HANDLE || 
         emaHandle == INVALID_HANDLE || 
         ema200Handle == INVALID_HANDLE) {
         Print("Un ou plusieurs handles d'indicateurs sont invalides");
         return false;
      }
      if(EnableSuperTrend && superTrendHandle == INVALID_HANDLE) {
         Print("L'indicateur SuperTrend est activé mais le handle est invalide");
         return false;
      }
      return true;
   }

   // Retourne le handle ATR
   int GetATRHandle() {
      return atrHandle;
   }

   // Libère tous les handles
   void ReleaseAllHandles() {
      if(macdHandle != INVALID_HANDLE)       { IndicatorRelease(macdHandle); macdHandle = INVALID_HANDLE; }
      if(rsiHandle != INVALID_HANDLE)        { IndicatorRelease(rsiHandle); rsiHandle = INVALID_HANDLE; }
      if(atrHandle != INVALID_HANDLE)        { IndicatorRelease(atrHandle); atrHandle = INVALID_HANDLE; }
      if(adxHandle != INVALID_HANDLE)        { IndicatorRelease(adxHandle); adxHandle = INVALID_HANDLE; }
      if(bbHandle != INVALID_HANDLE)         { IndicatorRelease(bbHandle); bbHandle = INVALID_HANDLE; }
      if(emaHandle != INVALID_HANDLE)        { IndicatorRelease(emaHandle); emaHandle = INVALID_HANDLE; }
      if(ema200Handle != INVALID_HANDLE)     { IndicatorRelease(ema200Handle); ema200Handle = INVALID_HANDLE; }
      if(superTrendHandle != INVALID_HANDLE) { IndicatorRelease(superTrendHandle); superTrendHandle = INVALID_HANDLE; }
   }

   // Vérifie si les indicateurs sont prêts
   bool AreIndicatorsReady(bool verbose = true) {
      string missing = "";
      
      if(!IsIndicatorReady(macdHandle)) missing += "MACD,";
      if(!IsIndicatorReady(rsiHandle)) missing += "RSI,";
      if(!IsIndicatorReady(atrHandle)) missing += "ATR,";
      if(!IsIndicatorReady(adxHandle)) missing += "ADX,";
      if(!IsIndicatorReady(bbHandle)) missing += "Bollinger Bands,";
      if(!IsIndicatorReady(emaHandle)) missing += "EMA20,";
      if(!IsIndicatorReady(ema200Handle)) missing += "EMA200,";
      if(EnableSuperTrend && !IsIndicatorReady(superTrendHandle)) missing += "SuperTrend,";

      if(missing != "" && verbose) 
         Print("Indicateurs manquants: ", missing);

      return (missing == "");
   }

   // Vérifie si un indicateur est prêt
   bool IsIndicatorReady(int handle, int min_bars = 100) {
      if(handle == INVALID_HANDLE) return false;

      int calculated = BarsCalculated(handle);
      if(calculated < min_bars) return false;

      // Vérification supplémentaire pour SuperTrend
      if(handle == superTrendHandle) {
         double testValue[1];
         if(CopyBuffer(handle, 0, 0, 1, testValue) <= 0 || !MathIsValidNumber(testValue[0])) {
            Print("Données SuperTrend invalides à la position 0");
            return false;
         }
      }

      return true;
   }

   // Stratégie Checklist
   bool ChecklistStrategySignal(STradeSignal &signal) {
      double ema200[2], rsi[2], adx[2], atr[1], macdMain[2], macdSignal[2];
      if(CopyBuffer(ema200Handle, 0, 1, 2, ema200) < 2 ||
         CopyBuffer(rsiHandle, 0, 1, 2, rsi) < 2 ||
         CopyBuffer(adxHandle, 0, 1, 2, adx) < 2 ||
         CopyBuffer(atrHandle, 0, 0, 1, atr) < 1 ||
         CopyBuffer(checklistMacdHandle, 0, 1, 2, macdMain) < 2 ||
         CopyBuffer(checklistMacdHandle, 1, 1, 2, macdSignal) < 2) {
         Print("Échec de la copie des buffers d'indicateurs: ", GetLastError());
         signal.valid = false;
         return false;
      }

      double spread_pips = GetSpreadPips();
      double spread_threshold = GetDynamicSpreadThreshold();

      if(spread_pips > spread_threshold) {
         signal.valid = false;
         signal.comment = StringFormat("⛔ Blocage du trade : spread %.2f > %.2f (seuil dynamique)", spread_pips, spread_threshold);
         PrintFormat("⛔ Spread trop élevé : %.2f > %.2f pips", spread_pips, spread_threshold);
         return false;
      }

      double price      = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double minATR     = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE) * 10;
      double minADX     = 20;
      double minRSI     = 40, maxRSI = 60;
      MqlDateTime tm;
      TimeToStruct(TimeCurrent(), tm);
      int hour = tm.hour;

      // Filtres marché (à compléter selon tes préférences)

      // Vérification des confirmations
      int confirmations = 0;
      STradeSignal st1, st2, st3, st4, st5;

      // Nouvelle gestion SuperTrend dynamique et robuste :
      bool supertrend_ready = false;
      if(EnableSuperTrend) {
         if(superTrendHandle == INVALID_HANDLE) {
            Print("SuperTrend handle invalide, tentative de réinitialisation...");
            ResetSuperTrendHandle();
         }
         // On tente de récupérer le signal, on ne désactive plus définitivement
         if(superTrendHandle != INVALID_HANDLE && DetectSuperTrendSignal(st1) && st1.valid) {
            confirmations++;
            supertrend_ready = true;
         } else {
            Print("SuperTrend non prêt ou signal non valide, on retente à chaque tick.");
         }
      }

      bool s2 = DetectSRRetestSignal(st2) && st2.valid;
      bool s3 = DetectBreakoutSignal(st3) && st3.valid;
      bool s4 = DetectPullbackEMASignal(st4) && st4.valid;
      bool s5 = DetectScalpingSignal(st5) && st5.valid;

      if(s2) confirmations++;
      if(s3) confirmations++;
      if(s4) confirmations++;
      if(s5) confirmations++;

      // Logs détaillés pour le debug
      PrintFormat("DEBUG: SuperTrend=%d, RetestSR=%d, Breakout=%d, PullbackEMA=%d, Scalping=%d, Confirmations=%d",
         (int)supertrend_ready, (int)s2, (int)s3, (int)s4, (int)s5, confirmations);

      if(confirmations < 3) {
         signal.valid = false;
         signal.comment = "Aucun signal valide trouvé";
         return false;
      }

      // Décision finale
      int buyVotes  = (st1.isBuySignal ? 1 : 0) + (st2.isBuySignal ? 1 : 0) +
                     (st3.isBuySignal ? 1 : 0) + (st4.isBuySignal ? 1 : 0) +
                     (st5.isBuySignal ? 1 : 0);
      int sellVotes = 5 - buyVotes;
      signal.isBuySignal = (buyVotes > sellVotes);
      signal.price = price;
      SetStopLossTakeProfit(signal, signal.isBuySignal);
      signal.valid = true;
      signal.comment = StringFormat("ChecklistStrategy (%d confirmations, EMA/ADX/ATR/RSI/MACD/Spread/Drawdown/News OK)", confirmations);
      return true;
   }

   // Détection du signal SuperTrend
// === Détection du signal SuperTrend ===
bool DetectSuperTrendSignal(STradeSignal &signal) {
    Print("DEBUG: Entrée DetectSuperTrendSignal");
    signal.valid = false;

    double supertrend[3];
    int copiedST = CopyBuffer(superTrendHandle, 0, 0, 3, supertrend);
    if(copiedST < 3) {
        Print("ERREUR: CopyBuffer SuperTrend (copié=", copiedST, ")");
        signal.valid = false;
        return false;
    }

    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);

    double ema200_buff[1];
    int copiedEMA = CopyBuffer(ema200Handle, 0, 0, 1, ema200_buff);
    if(copiedEMA < 1) {
        Print("ERREUR: CopyBuffer EMA200 (copié=", copiedEMA, ")");
        signal.valid = false;
        return false;
    }
    double ema200 = ema200_buff[0];

    double margin = ema200 * 0.02; // ±2% autour de la moyenne

    // Log contextuel complet
    Print("DEBUG ST: st1=", supertrend[1], " price=", price, " ema200=", ema200, " margin=", margin);

    // Signal BUY
    if(supertrend[1] < price && price > ema200 - margin) {
        signal.isBuySignal = true;
        signal.price = price;
        SetStopLossTakeProfit(signal, true);
        signal.valid = true;
        signal.comment = "SuperTrend BUY (filter EMA200 permissif)";
        signal.strategy = STRAT_SUPERTREND;
        Print("SIGNAL: SuperTrend BUY détecté - price=", price, " SL=", signal.sl, " TP=", signal.tp);
        return true;
    }

    // Signal SELL
    if(supertrend[1] > price && price < ema200 + margin) {
        signal.isBuySignal = false;
        signal.price = price;
        SetStopLossTakeProfit(signal, false);
        signal.valid = true;
        signal.comment = "SuperTrend SELL (filter EMA200 permissif)";
        signal.strategy = STRAT_SUPERTREND;
        Print("SIGNAL: SuperTrend SELL détecté - price=", price, " SL=", signal.sl, " TP=", signal.tp);
        return true;
    }

    Print("NO SIGNAL: ST[1]=", supertrend[1], " price=", price, " ema200=", ema200, " margin=", margin);
    signal.valid = false;
    return false;
}
   // Détection du signal Retest SR
   // === Détection du signal Retest SR ===
bool DetectSRRetestSignal(STradeSignal &signal) {
    Print("DEBUG: Entrée DetectSRRetestSignal");
    signal.valid = false;

    double srLevels[50];
    int nbLevels = LoadSRLevels(srLevels);
    if(nbLevels == 0) {
        Print("ERREUR: Aucun niveau SR trouvé");
        signal.valid = false;
        return false;
    }

    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double ema200[1];
    int copiedEMA = CopyBuffer(ema200Handle, 0, 0, 1, ema200);
    if(copiedEMA < 1) {
        Print("ERREUR: CopyBuffer EMA200 (copié=", copiedEMA, ")");
        signal.valid = false;
        return false;
    }

    double tolerance = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 20;

    for(int i = 0; i < nbLevels; i++) {
        Print("DEBUG: Test niveau SR[", i, "]=", srLevels[i], " price=", price, " ema200=", ema200[0], " tolerance=", tolerance);

        // Signal BUY
        if(MathAbs(price - srLevels[i]) < tolerance && price > ema200[0]) {
            signal.isBuySignal = true;
            signal.price = price;
            SetStopLossTakeProfit(signal, true);
            signal.valid = true;
            signal.comment = "SR Retest BUY";
            Print("SIGNAL: SR Retest BUY détecté - price=", price, " SL=", signal.sl, " TP=", signal.tp);
            return true;
        }

        // Signal SELL
        if(MathAbs(price - srLevels[i]) < tolerance && price < ema200[0]) {
            signal.isBuySignal = false;
            signal.price = price;
            SetStopLossTakeProfit(signal, false);
            signal.valid = true;
            signal.comment = "SR Retest SELL";
            Print("SIGNAL: SR Retest SELL détecté - price=", price, " SL=", signal.sl, " TP=", signal.tp);
            return true;
        }
    }

    Print("NO SIGNAL: Aucun retest SR détecté. price=", price, " ema200=", ema200[0], " nbLevels=", nbLevels);
    signal.valid = false;
    return false;
}
   // === Détection du signal Breakout (avec logs détaillés) ===
bool DetectBreakoutSignal(STradeSignal &signal) {
    Print("DEBUG: Entrée DetectBreakoutSignal");
    signal.valid = false;

    int rangeLookback = 20;
    double highestHigh = iHigh(_Symbol, _Period, 1);
    double lowestLow = iLow(_Symbol, _Period, 1);

    // Recherche du plus haut et du plus bas sur la période de lookback
    for(int i = 2; i <= rangeLookback+1; i++) {
        double high = iHigh(_Symbol, _Period, i);
        double low = iLow(_Symbol, _Period, i);
        if(high > highestHigh) highestHigh = high;
        if(low < lowestLow) lowestLow = low;
    }
    Print("DEBUG: highestHigh=", highestHigh, " lowestLow=", lowestLow);

    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);

    double ema200[1];
    int copiedEMA = CopyBuffer(ema200Handle, 0, 0, 1, ema200);
    if(copiedEMA < 1) {
        Print("ERREUR: CopyBuffer EMA200 (copié=", copiedEMA, ")");
        signal.valid = false;
        return false;
    }

    Print("DEBUG: price=", price, " ema200=", ema200[0]);

    // Breakout haussier
    if(price > highestHigh && price > ema200[0]) {
        signal.isBuySignal = true;
        signal.price = price;
        SetStopLossTakeProfit(signal, true);
        signal.valid = true;
        signal.comment = "Breakout BUY";
        Print("SIGNAL: Breakout BUY détecté - price=", price, " highestHigh=", highestHigh, " ema200=", ema200[0]);
        return true;
    }
    
    // Breakout baissier
    if(price < lowestLow && price < ema200[0]) {
        signal.isBuySignal = false;
        signal.price = price;
        SetStopLossTakeProfit(signal, false);
        signal.valid = true;
        signal.comment = "Breakout SELL";
        Print("SIGNAL: Breakout SELL détecté - price=", price, " lowestLow=", lowestLow, " ema200=", ema200[0]);
        return true;
    }
    
    Print("NO SIGNAL: price=", price, " highestHigh=", highestHigh, " lowestLow=", lowestLow, " ema200=", ema200[0]);
    signal.valid = false;
    return false;
}

   // === Détection du signal Pullback EMA (avec logs détaillés) ===
bool DetectPullbackEMASignal(STradeSignal &signal) {
    Print("DEBUG: Entrée DetectPullbackEMASignal");
    signal.valid = false;

    double ema20[2], ema200[2], rsi[2], adx[2];
    int copiedEMA20  = CopyBuffer(emaHandle, 0, 1, 2, ema20);
    int copiedEMA200 = CopyBuffer(ema200Handle, 0, 1, 2, ema200);
    int copiedRSI    = CopyBuffer(rsiHandle, 0, 1, 2, rsi);
    int copiedADX    = CopyBuffer(adxHandle, 0, 1, 2, adx);

    if(copiedEMA20 < 2 || copiedEMA200 < 2 || copiedRSI < 2 || copiedADX < 2) {
        Print("ERREUR: Échec de la copie des buffers d'indicateurs : ema20=", copiedEMA20, 
              " ema200=", copiedEMA200, " rsi=", copiedRSI, " adx=", copiedADX, 
              " - Code erreur=", GetLastError());
        signal.valid = false;
        return false;
    }

    double tolerance = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 10;
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double prevClose = iClose(_Symbol, _Period, 1);

    Print("DEBUG: price=", price, " ema20[1]=", ema20[1], " ema200[1]=", ema200[1], 
          " rsi[1]=", rsi[1], " adx[1]=", adx[1], " prevClose=", prevClose, " tolerance=", tolerance);

    // Pullback haussier (achat)
    if(price > ema200[1] && MathAbs(price - ema20[1]) < tolerance && ema20[1] > ema200[1]) {
        Print("DEBUG: Condition Pullback haussier détectée.");
        if(prevClose < ema20[1] && adx[1] > 20 && rsi[1] > 40) {
            Print("SIGNAL: Pullback EMA BUY détecté (RSI/ADX OK)");
            signal.isBuySignal = true;
            signal.price = price;
            SetStopLossTakeProfit(signal, true);
            signal.valid = true;
            signal.comment = "Pullback EMA BUY (RSI/ADX OK)";
            return true;
        } else {
            Print("DEBUG: Pullback haussier - conditions secondaires NON remplies (prevClose=", prevClose, ", adx=", adx[1], ", rsi=", rsi[1], ")");
        }
    }

    // Pullback baissier (vente)
    if(price < ema200[1] && MathAbs(price - ema20[1]) < tolerance && ema20[1] < ema200[1]) {
        Print("DEBUG: Condition Pullback baissier détectée.");
        if(prevClose > ema20[1] && adx[1] > 20 && rsi[1] < 60) {
            Print("SIGNAL: Pullback EMA SELL détecté (RSI/ADX OK)");
            signal.isBuySignal = false;
            signal.price = price;
            SetStopLossTakeProfit(signal, false);
            signal.valid = true;
            signal.comment = "Pullback EMA SELL (RSI/ADX OK)";
            return true;
        } else {
            Print("DEBUG: Pullback baissier - conditions secondaires NON remplies (prevClose=", prevClose, ", adx=", adx[1], ", rsi=", rsi[1], ")");
        }
    }

    Print("NO SIGNAL: Pullback EMA - AUCUN signal détecté. price=", price, " ema20[1]=", ema20[1], " ema200[1]=", ema200[1]);
    signal.valid = false;
    return false;
}
   // Détection du signal Scalping
// === Détection du signal Scalping ===
// Analyse plusieurs indicateurs pour détecter une opportunité de scalping.
// Retourne true si un signal valide est détecté et remplit la structure signal.
bool DetectScalpingSignal(STradeSignal &signal) {
    Print("DEBUG: Entrée DetectScalpingSignal");
    signal.valid = false;

    // Buffers pour la récupération des valeurs d'indicateurs
    double ema20[2], ema200[2], rsi[2], adx[2], atr[1];

    // Récupération des dernières valeurs d'indicateurs (2 pour EMA/RSI/ADX, 1 pour ATR)
    int copiedEMA20  = CopyBuffer(emaHandle, 0, 1, 2, ema20);
    int copiedEMA200 = CopyBuffer(ema200Handle, 0, 1, 2, ema200);
    int copiedRSI    = CopyBuffer(rsiHandle, 0, 1, 2, rsi);
    int copiedADX    = CopyBuffer(adxHandle, 0, 1, 2, adx);
    int copiedATR    = CopyBuffer(atrHandle, 0, 0, 1, atr);

    // Vérification de la bonne copie des buffers
    if(copiedEMA20 < 2 || copiedEMA200 < 2 || copiedRSI < 2 || copiedADX < 2 || copiedATR < 1) {
        Print("ERREUR: Échec de la copie des buffers d'indicateurs : ema20=", copiedEMA20, 
              " ema200=", copiedEMA200, " rsi=", copiedRSI, " adx=", copiedADX, " atr=", copiedATR, 
              " - Code erreur=", GetLastError());
        signal.valid = false;
        return false;
    }

    // Vérification du spread avant tout signal
    double spread_pips = GetSpreadPips();
    double spread_threshold = GetDynamicSpreadThreshold();

    if(spread_pips > spread_threshold) {
        signal.valid = false;
        signal.comment = StringFormat("⛔ Blocage du trade : spread %.2f > %.2f (seuil dynamique)", spread_pips, spread_threshold);
        PrintFormat("⛔ Spread trop élevé : %.2f > %.2f pips", spread_pips, spread_threshold);
        return false;
    }

    // Récupération du prix courant et calcul des seuils pour les filtres
    double price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    double minATR = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 8;        // ATR minimum (volatilité)
    double minADX = 18;                                                 // ADX minimum (tendance)
    double minMicroPullback = SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 2; // Pullback max autorisé

    // LOG contextuel complet
    Print("DEBUG: price=", price, " ema20[1]=", ema20[1], " ema200[1]=", ema200[1], 
          " rsi[1]=", rsi[1], " adx[1]=", adx[1], " atr[0]=", atr[0], 
          " spread_pips=", spread_pips);

    // --- Signal d'achat scalping (BUY) ---
    if(ema20[1] > ema200[1] && price > ema20[1] && rsi[1] > 35 && rsi[1] < 65 && 
       adx[1] > minADX && atr[0] > minATR && (price - ema20[1]) < minMicroPullback) {
        signal.isBuySignal = true;
        signal.price = price;
        SetStopLossTakeProfit(signal, true);
        signal.valid = true;
        signal.comment = "Scalping BUY (EMA/RSI/ADX/ATR/SPREAD)";
        Print("SIGNAL: Scalping BUY détecté - price=", price, " SL=", signal.sl, " TP=", signal.tp);
        return true;
    }

    // --- Signal de vente scalping (SELL) ---
    if(ema20[1] < ema200[1] && price < ema20[1] && rsi[1] > 35 && rsi[1] < 65 && 
       adx[1] > minADX && atr[0] > minATR && (ema20[1] - price) < minMicroPullback) {
        signal.isBuySignal = false;
        signal.price = price;
        SetStopLossTakeProfit(signal, false);
        signal.valid = true;
        signal.comment = "Scalping SELL (EMA/RSI/ADX/ATR/SPREAD)";
        Print("SIGNAL: Scalping SELL détecté - price=", price, " SL=", signal.sl, " TP=", signal.tp);
        return true;
    }

    // --- Aucun signal ---
    Print("NO SIGNAL: Scalping - AUCUN signal détecté. price=", price, " ema20[1]=", ema20[1], " ema200[1]=", ema200[1]);
    signal.valid = false;
    return false;
}

private:
   // Attend que les données de l'indicateur soient prêtes
   bool WaitForIndicatorData(int handle, string name, int timeout_ms = 3000) {
      if(handle == INVALID_HANDLE) return false;
      
      uint start = GetTickCount();
      while((int)(GetTickCount() - start) < timeout_ms) {
         if(BarsCalculated(handle) > 100) return true;
         Sleep(50);
      }
      Print(name, " - Timeout après ", timeout_ms, " ms");
      return false;
   }
   
   // === Attend que les données du SuperTrend soient prêtes (cas spécial) ===
// Retourne true si assez de barres calculées et synchrone avec le graphique, false sinon.
bool WaitForSuperTrendData(int handle, int timeout_ms = 3000) {
    if(handle == INVALID_HANDLE) {
        Print("SuperTrend Handle invalide !");
        return false;
    }
    int calculated = BarsCalculated(handle);
    int chartBars = iBars(_Symbol, _Period);

    // Suffisamment de barres, indicateur à jour
    if(calculated > 10 && (chartBars - calculated) < 10) {
        Print("SuperTrend - Données OK, BarsCalculated=", calculated, " ChartBars=", chartBars);
        return true;
    }

    uint start = GetTickCount();
    while((int)(GetTickCount() - start) < timeout_ms) {
        calculated = BarsCalculated(handle);
        chartBars = iBars(_Symbol, _Period);
        if(calculated > 10 && (chartBars - calculated) < 10) {
            Print("SuperTrend - Données OK aprés attente, BarsCalculated=", calculated, " ChartBars=", chartBars);
            return true;
        }
        Sleep(50);
    }
    Print("SuperTrend Timeout - BarsCalculated: ", calculated, ", Chart bars: ", chartBars);
    return false;
}
   // Initialise un indicateur avec système de réessai
   // === Initialise un indicateur avec plusieurs tentatives (robuste, commenté, optimisé) ===
// handle : variable de handle à mettre à jour
// newHandle : handle à tester/initialiser
// name : nom de l'indicateur (pour logs)
// max_retries : nombre maximum de tentatives
// delay_ms : délai entre les tentatives (par défaut 500ms)
bool InitIndicatorWithRetry(int &handle, int newHandle, string name, int max_retries = 3, int delay_ms = 500) {
    int attempts = 0;
    bool isSuperTrend = (name == "SuperTrend");
    while(attempts < max_retries) {
        handle = newHandle;
        Print("DEBUG: Tentative n°", (attempts+1), " d'initialisation de ", name, " (handle=", handle, ")");
        if(handle != INVALID_HANDLE) {
            // Attente des données selon le type d'indicateur
            bool dataReady = isSuperTrend 
                ? WaitForSuperTrendData(handle) 
                : WaitForIndicatorData(handle, name);
            if(dataReady) {
                Print("SUCCÈS: ", name, " initialisé et données prêtes (handle=", handle, ")");
                return true;
            } else {
                Print("ATTENTE: ", name, " non prêt après initialisation (handle=", handle, ")");
            }
        } else {
            Print("ERREUR: Handle invalide pour ", name, " à la tentative ", (attempts+1));
        }
        // Libération du handle si nécessaire
        if(handle != INVALID_HANDLE) IndicatorRelease(handle);
        Sleep(delay_ms);
        attempts++;
    }
    Print("ÉCHEC: Impossible d'initialiser ", name, " après ", max_retries, " tentatives");
    return false;
}
   // === Réinitialise proprement le handle SuperTrend ===
// - Libère l'ancien handle si nécessaire
// - Crée un nouveau handle avec les paramètres courants
// - Vérifie si les données de l'indicateur sont prêtes
// - Loggue chaque étape pour faciliter le debug
// - Retourne true si succès, false si échec
bool ResetSuperTrendHandle() {
    Print("DEBUG: Début ResetSuperTrendHandle()");

    // Libération de l'ancien handle si encore actif
    if(superTrendHandle != INVALID_HANDLE) {
        Print("DEBUG: Libération de l'ancien handle SuperTrend (", superTrendHandle, ")");
        IndicatorRelease(superTrendHandle);
        superTrendHandle = INVALID_HANDLE;
    }

    // Création du nouveau handle
    superTrendHandle = iCustom(_Symbol, _Period, "SuperTrend", SuperTrend_ATRPeriod, SuperTrend_Multiplier);

    // Vérification de la création
    if(superTrendHandle == INVALID_HANDLE) {
        Print("CRITIQUE: Impossible de réinitialiser SuperTrend!");
        return false;
    } else {
        Print("SuperTrend réinitialisé avec handle: ", superTrendHandle);
        // Attente des données de l'indicateur (sécurise les accès ultérieurs)
        if(!WaitForSuperTrendData(superTrendHandle, 3000)) {
            Print("CRITIQUE: SuperTrend - Données non disponibles après réinitialisation!");
            IndicatorRelease(superTrendHandle);
            superTrendHandle = INVALID_HANDLE;
            return false;
        }
        Print("DEBUG: SuperTrend prêt et synchronisé");
    }
    return true;
}
   // === Définit les niveaux SL/TP de façon robuste et optimisée ===
void SetStopLossTakeProfit(STradeSignal &signal, bool isBuy) {
    // --- Récupération de l'ATR via CopyBuffer ---
    double atrBuffer[1];
    int copied = CopyBuffer(atrHandle, 0, 0, 1, atrBuffer);
    if(copied <= 0 || atrBuffer[0] <= 0) {
        Print("ERREUR: ATR invalide ou CopyBuffer échoué");
        signal.valid = false;
        return;
    }
    double atr = atrBuffer[0];

    // Forcer un minimum d'ATR pour éviter stops trop petits (backtest/situations extrêmes)
    double minATR = _Point * 100;
    if(atr < minATR) {
        PrintFormat("ATR trop bas (%.5f), forcé à min=%.5f", atr, minATR);
        atr = minATR;
    }

    // --- Infos symboles & contraintes broker ---
    double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
    double minStopLevelPoints = (double)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
    double minStopLevel = (minStopLevelPoints > 0 ? minStopLevelPoints : 2.0) * point;

    PrintFormat("DEBUG: SYMBOL_TRADE_STOPS_LEVEL=%d -> minStopLevel=%.5f", (int)minStopLevelPoints, minStopLevel);

    // --- Calcul distances SL/TP ---
    double stopDistance = MathMax(atr * 1.5, minStopLevel * 2);    // Distance SL >= 2x le minStopLevel
    double maxDistance  = atr * 4.0;
    double ratio        = 2.0;
    double price        = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK) : SymbolInfoDouble(_Symbol, SYMBOL_BID);

    // On limite la distance max si nécessaire
    stopDistance = MathMin(stopDistance, maxDistance);

    double sl, tp;
    if (isBuy) {
        sl = price - stopDistance;
        tp = price + stopDistance * ratio;
    } else {
        sl = price + stopDistance;
        tp = price - stopDistance * ratio;
    }

    // --- Log final du résultat calculé ---
    PrintFormat("SL/TP final => SL=%.5f | TP=%.5f | distance=%.5f | ATR=%.5f", sl, tp, stopDistance, atr);

    // --- Validation finale des niveaux et retour ---
    signal.sl = sl;
    signal.tp = tp;
    if (!ValidatePrices(price, sl, tp, isBuy)) {
        Print("SL/TP invalides après calcul. Signal abandonné.");
        signal.valid = false;
    } else {
        signal.valid = true;
    }
}

// === Charge les niveaux de support/résistance optimisés et robustes ===
// Retourne le nombre de niveaux trouvés, et rempli le tableau levels[] (hauts/bas significatifs fusionnés)
//+------------------------------------------------------------------+
//| Recherche et fusion des niveaux SR sans jamais sortir de l'array |
//| Retourne le nombre de niveaux trouvés dans levels[].             |
//+------------------------------------------------------------------+
int LoadSRLevels(double &levels[])
{
    // Réinitialise le tableau levels à vide
    if(!ArrayResize(levels, 0))
    {
        Print("Erreur : impossible de réinitialiser le tableau levels");
        return 0;
    }

    int lookback = 100;                      // Nombre de barres à analyser en arrière
    int bars = (int)Bars(_Symbol, _Period); // Nombre total de barres disponibles
    PrintFormat("LoadSRLevels - Bars disponibles : %d", bars);

    // Limite lookback au nombre réel de barres disponibles
    if (bars < lookback)
        lookback = bars;

    // Sécurité : au moins 7 barres nécessaires pour détecter pivots (car on regarde i-1 et i+1)
    if (lookback < 7)
    {
        Print("LoadSRLevels - Pas assez de barres pour analyser (moins de 7)");
        return 0;
    }

    // Recherche des pivots hauts et bas dans la fenêtre d'analyse
    for (int i = 3; i < lookback - 3; i++)
    {
        // Vérifie indices valides pour accéder aux barres
        if ((i + 1) >= bars || (i - 1) < 0)
        {
            PrintFormat("LoadSRLevels - Ignorer i=%d car index hors limites", i);
            continue;
        }

        // Récupère les hauts des barres i-1, i, i+1
        double high1 = iHigh(_Symbol, _Period, i + 1);
        double high2 = iHigh(_Symbol, _Period, i);
        double high3 = iHigh(_Symbol, _Period, i - 1);

        // Vérifie que les valeurs sont valides (pas NaN ou infini)
        if (MathIsValidNumber(high1) && MathIsValidNumber(high2) && MathIsValidNumber(high3))
        {
            // Condition pivot haut : barre centrale plus haute que ses voisines
            if (high2 > high1 && high2 > high3)
            {
                int idx = ArraySize(levels);
                if (ArrayResize(levels, idx + 1))
                {
                    levels[idx] = high2;
                    PrintFormat("Pivot haut détecté : levels[%d] = %.5f", idx, high2);
                }
                else
                {
                    Print("Erreur : ArrayResize failed lors de l'ajout d'un pivot haut");
                    return 0;
                }
            }
        }
        else
        {
            PrintFormat("Valeurs haut non valides aux indices [%d, %d, %d]", i + 1, i, i - 1);
        }

        // Récupère les bas des barres i-1, i, i+1
        double low1 = iLow(_Symbol, _Period, i + 1);
        double low2 = iLow(_Symbol, _Period, i);
        double low3 = iLow(_Symbol, _Period, i - 1);

        // Vérifie validité des valeurs bas
        if (MathIsValidNumber(low1) && MathIsValidNumber(low2) && MathIsValidNumber(low3))
        {
            // Condition pivot bas : barre centrale plus basse que ses voisines
            if (low2 < low1 && low2 < low3)
            {
                int idx = ArraySize(levels);
                if (ArrayResize(levels, idx + 1))
                {
                    levels[idx] = low2;
                    PrintFormat("Pivot bas détecté : levels[%d] = %.5f", idx, low2);
                }
                else
                {
                    Print("Erreur : ArrayResize failed lors de l'ajout d'un pivot bas");
                    return 0;
                }
            }
        }
        else
        {
            PrintFormat("Valeurs bas non valides aux indices [%d, %d, %d]", i + 1, i, i - 1);
        }
    }

    // --- Fusion des niveaux proches pour éviter doublons ---
    double fusionDistance = 10 * _Point;    // Distance seuil pour fusion (10 points)
    int n = ArraySize(levels);
    int i = 0;

    while (i < n)
    {
        int j = i + 1;
        while (j < n)
        {
            if (MathIsValidNumber(levels[i]) && MathIsValidNumber(levels[j]) &&
                MathAbs(levels[i] - levels[j]) < fusionDistance)
            {
                // Fusion des deux niveaux en moyenne
                levels[i] = (levels[i] + levels[j]) / 2.0;
                PrintFormat("Fusion niveaux : levels[%d] et levels[%d] -> %.5f", i, j, levels[i]);

                // Décale tous les éléments après j vers la gauche
                for (int k = j; k < n - 1; k++)
                {
                    if ((k + 1) < n)
                        levels[k] = levels[k + 1];
                }

                n--;
                if (!ArrayResize(levels, n))
                {
                    Print("Erreur : ArrayResize failed lors de la fusion des niveaux");
                    return n;
                }
                // Ne pas incrémenter j, on doit re-vérifier l'élément déplacé à la position j
            }
            else
            {
                j++;
            }
        }
        i++;
    }

    PrintFormat("LoadSRLevels - Total niveaux détectés : %d", n);
    return n;
}



   // Vérifie si les prix SL/TP sont valides pour un trade
   bool ValidatePrices(double entry_price, double stop_loss, double take_profit, bool isBuy) {
      long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double min_distance = stops_level * _Point;
      if(min_distance < _Point) min_distance = 2 * _Point; // sécurité

      if(isBuy) {
         if(stop_loss >= entry_price || take_profit <= entry_price) return false;
         if((entry_price - stop_loss) < min_distance || (take_profit - entry_price) < min_distance) return false;
      } else {
         if(stop_loss <= entry_price || take_profit >= entry_price) return false;
         if((stop_loss - entry_price) < min_distance || (entry_price - take_profit) < min_distance) return false;
      }
      return true;
   }
   
   // Calcule le spread actuel en pips pour le symbole courant
   public:
   double GetSpreadPips() {
      // Récupération des valeurs de base
      long spread_raw = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
      
      // Calcul de la taille d'un pip selon le type de symbole
      double pipSize = point; // Valeur par défaut
      
      // Or (GOLD/XAUUSD)
      if(StringFind(_Symbol, "GOLD") >= 0 || StringFind(_Symbol, "XAU") >= 0) {
         pipSize = (digits == 2) ? 0.01 : 0.1;
      }
      // Paires avec JPY
      else if(StringFind(_Symbol, "JPY") >= 0 && digits >= 2) {
         pipSize = 0.01;
      }
      // Cryptomonnaies
      else if(StringFind(_Symbol, "BTC") >= 0 || StringFind(_Symbol, "ETH") >= 0) {
         pipSize = 1.0;
      }
      // Forex 5/3 digits
      else if(digits == 5 || digits == 3) {
         pipSize = 0.0001;
      }
      // Forex 4/2 digits
      else if(digits == 4 || digits == 2) {
         pipSize = 0.0001;
      }
      
      // Calcul final du spread en pips
      double spread_pips = (spread_raw * point) / pipSize;
      
      if(EnableDebugLog) {
         PrintFormat("[SPREAD] %s: %d points | %d digits | Spread: %.2f pips",
                    _Symbol, spread_raw, digits, spread_pips);
      }
      
      return NormalizeDouble(spread_pips, 2);
   }
   
   /// @brief Calcule un seuil dynamique de spread en fonction de l'ATR, avec ajustement par symbole.
   public:
   double GetDynamicSpreadThreshold() {
      // 1. Paramètres par défaut selon le type de symbole
      double min_spread = 2.0;
      double max_spread = 5.0;
      double atr_multiplier = 0.7;
      string description = "AUTRE";
      
      if(StringFind(_Symbol, "GOLD") >= 0 || StringFind(_Symbol, "XAU") >= 0) {
         // Paramètres pour l'Or (XAUUSD/GOLD)
         min_spread = 30.0;
         max_spread = 80.0;
         atr_multiplier = 0.5;
         description = "OR";
      }
      else if(StringFind(_Symbol, "BTC") >= 0 || StringFind(_Symbol, "ETH") >= 0) {
         // Paramètres pour les cryptomonnaies
         min_spread = 50.0;
         max_spread = 150.0;
         atr_multiplier = 0.3;
         description = "CRYPTO";
      }
      else if(StringFind(_Symbol, "JPY") >= 0) {
         // Paramètres pour les paires JPY (USDJPYm, etc.)
         min_spread = 1.5;
         max_spread = 3.5;
         atr_multiplier = 0.8;
         description = "FOREX_JPY";
      }
      else if(StringFind(_Symbol, "EUR") >= 0 || StringFind(_Symbol, "GBP") >= 0 || 
              StringFind(_Symbol, "USD") >= 0 || StringFind(_Symbol, "CHF") >= 0) {
         // Paramètres pour forex majeur (EURUSD, GBPUSD, etc.)
         min_spread = 1.2;
         max_spread = 3.0;
         atr_multiplier = 1.0;
         description = "FOREX_MAJEUR";
      }
      
      // 2. Calcul de l'ATR (14 périodes) comme mesure de volatilité
      double atr = iATR(_Symbol, _Period, 14);
      double atr_pips = 0;
      
      if(atr > 0 && atr != EMPTY_VALUE && MathIsValidNumber(atr)) {
         double pipSize = GetPipSize();
         atr_pips = atr / pipSize;
      }
      
      // 3. Calcul du seuil dynamique
      double spread_threshold;
      
      if(atr_pips > 0) {
         // Formule dynamique basée sur la volatilité
         spread_threshold = MathMax(min_spread, 
                                  MathMin(atr_pips * atr_multiplier, max_spread));
      }
      else {
         // Fallback sur les paramètres statiques (80% du max)
         spread_threshold = max_spread * 0.8;
      }
      
      // 4. Journalisation des calculs pour débogage
      PrintFormat("[SPREAD THRESHOLD] %s | Type: %s | ATR: %.2f pips | Seuil: %.2f pips (Min: %.2f, Max: %.2f)",
                  _Symbol, description, atr_pips, spread_threshold, 
                  min_spread, max_spread);
                  
      return NormalizeDouble(spread_threshold, 2);
   }
   
   // Helper function - Calcule la taille d'un pip pour le symbole courant
   double GetPipSize() {
      int digits = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
      
      // Or (GOLD/XAUUSD)
      if(StringFind(_Symbol, "GOLD") >= 0 || StringFind(_Symbol, "XAU") >= 0) {
         return (digits == 2) ? 0.01 : 0.1;
      }
      // Paires avec JPY
      else if(StringFind(_Symbol, "JPY") >= 0 && digits >= 2) {
         return 0.01;
      }
      // Cryptomonnaies
      else if(StringFind(_Symbol, "BTC") >= 0 || StringFind(_Symbol, "ETH") >= 0) {
         return 1.0;
      }
      // Forex 5/3 digits
      else if(digits == 5 || digits == 3) {
         return 0.0001;
      }
      // Forex 4/2 digits
      else if(digits == 4 || digits == 2) {
         return 0.0001;
      }
      
      // Cas par défaut (devrait rarement arriver)
      return SymbolInfoDouble(_Symbol, SYMBOL_POINT) * 10;
   }
};

//+------------------------------------------------------------------+
//| Classe CTradeManager - Gestion des opérations de trading        |
//+------------------------------------------------------------------+
class CTradeManager {
private:
   CRiskManager *riskManager;               // Gestionnaire de risques
   CTrade trade;                            // Objet de trading

public:
   // Constructeur
   CTradeManager(CRiskManager *manager) : riskManager(manager) {
      trade.SetExpertMagicNumber(MagicNumber);
      trade.SetMarginMode();
      trade.SetTypeFillingBySymbol(_Symbol);
      trade.SetDeviationInPoints(Slippage);
   }

   // Exécute un trade basé sur un signal
   bool ExecuteTrade(const STradeSignal &signal) {
      if(!signal.valid || !CanOpenNewPosition(_Symbol)) {
         Print("Impossible d'exécuter le trade - signal invalide ou positions max atteintes");
         return false;
      }

      double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
      double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      double market_price = signal.isBuySignal ? ask : bid;

      double lots = riskManager.CalculatePositionSize(market_price, signal.sl);
      if(lots <= 0) {
         Print("Taille de lot calculée invalide: ", lots);
         return false;
      }

      if(signal.sl <= 0 || signal.tp <= 0) {
         Print("SL ou TP invalides: SL=", signal.sl, " TP=", signal.tp);
         return false;
      }

      if(!ValidatePrices(market_price, signal.sl, signal.tp, signal.isBuySignal)) {
         Print("SL/TP invalides pour le prix actuel");
         return false;
      }

      PrintFormat("\xF0\x9F\x93\x8C Signal reçu : %s | Lots=%.2f | Prix=%.2f | SL=%.2f | TP=%.2f",
                  signal.isBuySignal ? "BUY" : "SELL",
                  lots, signal.price, signal.sl, signal.tp);

      // Envoi sans SL/TP initial pour contourner l'erreur 4753
      bool result = signal.isBuySignal ?
                    trade.Buy(lots, _Symbol, 0, 0, 0, signal.comment) :
                    trade.Sell(lots, _Symbol, 0, 0, 0, signal.comment);

      if(result) {
         ulong deal_ticket = trade.ResultDeal();
         double profit = 0.0;
         if(deal_ticket > 0) {
            profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
         }

         // Ajout SL/TP après ouverture
         if(!trade.PositionModify(_Symbol, signal.sl, signal.tp)) {
            Print("⚠️ Échec de l'ajout SL/TP après ouverture : ", trade.ResultRetcodeDescription());
         } else {
            PrintFormat("✅ SL/TP appliqués après ouverture : SL=%.5f | TP=%.5f", signal.sl, signal.tp);
         }

         riskManager.UpdateTradeResult(profit);

         if(EnableNotifications) {
            string msg = StringFormat("New %s trade opened via %s. Lots: %.2f SL: %.5f TP: %.5f",
                                      signal.isBuySignal ? "BUY" : "SELL",
                                      EnumToString(signal.strategy),
                                      lots, signal.sl, signal.tp);
            Alert(_Symbol + " " + EnumToString(_Period) + ": " + msg);
            if(EnableSound) PlaySound("alert.wav");
         }
         return true;
      }

      Print("Échec de l'exécution du trade. Erreur: ", GetLastError());
      return false;
   }

   // Gère les positions ouvertes
   void ManagePositions() {
      for(int i = (int)PositionsTotal() - 1; i >= 0; i--) {
         ulong ticket = PositionGetTicket(i);
         if(PositionSelectByTicket(ticket)) {
            string pos_symbol = PositionGetString(POSITION_SYMBOL);
            int pos_magic     = (int)PositionGetInteger(POSITION_MAGIC);

            if(pos_symbol != _Symbol || pos_magic != MagicNumber) continue;

            double entry = PositionGetDouble(POSITION_PRICE_OPEN);
            double tp = PositionGetDouble(POSITION_TP);
            double sl = PositionGetDouble(POSITION_SL);
            double volume = PositionGetDouble(POSITION_VOLUME);
            ENUM_POSITION_TYPE type = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);

            ManagePartialClose(ticket, type, entry, sl, volume);
            ManageTrailingStop(ticket, type, entry, sl, tp);
         }
      }
   }

   // Vérifie si une nouvelle position peut être ouverte
   bool CanOpenNewPosition(string symbol) {
      if(riskManager.GetOpenPositionsCount(symbol) >= MAX_POSITIONS_PER_SYMBOL) {
         Print("Max positions (", MAX_POSITIONS_PER_SYMBOL, ") atteint pour ", symbol);
         return false;
      }

      if(!riskManager.CheckMinTimeBetweenTrades(MinMinutesBetweenTrades)) {
         Print("Temps minimum entre les trades non atteint");
         return false;
      }

      return CheckSpreadConditions(symbol);
   }

private:
   // Gère la fermeture partielle
   void ManagePartialClose(ulong ticket, ENUM_POSITION_TYPE type, double entry, double sl, double volume) {
      if(volume < 0.2) return;

      double stopDistance = MathAbs(entry - sl);
      if(stopDistance <= 0) return;

      double currentPrice = (type == POSITION_TYPE_BUY) ? SymbolInfoDouble(_Symbol, SYMBOL_BID) :
                                                          SymbolInfoDouble(_Symbol, SYMBOL_ASK);

      double r = (type == POSITION_TYPE_BUY) ? (currentPrice - entry) / stopDistance :
                                               (entry - currentPrice) / stopDistance;

      if(r >= 1.0) {
         PartialClose(ticket, 0.5);
      }
   }

   // Gère le trailing stop
   void ManageTrailingStop(ulong ticket, ENUM_POSITION_TYPE type, double entry, double &sl, double tp) {
      double atr = iATR(_Symbol, _Period, ATRPeriod);
      double profit = PositionGetDouble(POSITION_PROFIT);

      if(profit > atr * 100) {
         double newSL = 0;
         if(type == POSITION_TYPE_BUY) {
            newSL = SymbolInfoDouble(_Symbol, SYMBOL_BID) - atr;
            if(newSL > sl && newSL > entry) {
               trade.PositionModify(ticket, newSL, tp);
            }
         } else {
            newSL = SymbolInfoDouble(_Symbol, SYMBOL_ASK) + atr;
            if(newSL < sl && newSL < entry) {
               trade.PositionModify(ticket, newSL, tp);
            }
         }
      }
   }

   // Ferme partiellement une position
   void PartialClose(ulong ticket, double percentage) {
      if(PositionSelectByTicket(ticket)) {
         double vol = PositionGetDouble(POSITION_VOLUME);
         double closeLots = MathMax(SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN), vol * percentage);
         if(closeLots > 0) {
            trade.PositionClosePartial(ticket, closeLots);
         }
      }
   }

   // Vérifie les conditions de spread
   bool CheckSpreadConditions(string symbol) {
      // Utilisation de la fonction unifiée de calcul du spread
      double spread_pips = strategyManager.GetSpreadPips();
      double max_spread_pips = strategyManager.GetDynamicSpreadThreshold();
      
      if(spread_pips > max_spread_pips) {
         PrintFormat("⛔ Blocage du trade : spread %.2f > %.2f pips (seuil dynamique)", 
                  spread_pips, max_spread_pips);
         return false;
      }
      
      // Journalisation détaillée pour le débogage
      PrintFormat("[SPREAD CHECK] %s - Spread: %.2f pips | Seuil: %.2f pips | Statut: %s",
               symbol, spread_pips, max_spread_pips, 
               (spread_pips <= max_spread_pips) ? "OK" : "Trop élevé");
               
      return (spread_pips <= max_spread_pips);
   }
   
   // Vérifie si les prix SL/TP sont valides pour un trade
   bool ValidatePrices(double entry_price, double stop_loss, double take_profit, bool isBuy) {
      long stops_level = SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double min_distance = stops_level * _Point;
      if (min_distance < _Point) min_distance = 2 * _Point; // sécurité

      if (isBuy) {
         if (stop_loss >= entry_price || take_profit <= entry_price) return false;
         if ((entry_price - stop_loss) < min_distance || (take_profit - entry_price) < min_distance) return false;
      }
      else {
         if (stop_loss <= entry_price || take_profit >= entry_price) return false;
         if ((stop_loss - entry_price) < min_distance || (entry_price - take_profit) < min_distance) return false;
      }
      return true;
   }
};

//===================================================
// SECTION 7 : INSTANCES GLOBALES ET UTILITAIRES
//===================================================

// Instances globales des gestionnaires
CRiskManager riskManager(MaxDailyLossPercent, MaxLossPercent, MaxConsecutiveLosses, PauseAfterLosses, PauseDurationMinutes);
CStrategyManager strategyManager;
CTradeManager tradeManager(&riskManager);

//+------------------------------------------------------------------+
//| Fonctions utilitaires                                           |
//+------------------------------------------------------------------+

// Formatte un nombre avec signe
string FormatSigned(double value, int digits=2) {
   if(value >= 0.0)
      return("+" + DoubleToString(value, digits));
   return(DoubleToString(value, digits));
}

// Convertit un timestamp en date seule
datetime DateOfDay(datetime t) {
   MqlDateTime str;
   TimeToStruct(t, str);
   str.hour = 0;
   str.min = 0;
   str.sec = 0;
   return(StructToTime(str));
}

// Retourne la dernière stratégie utilisée
string LastStrategyUsed() {
   if(PositionSelect(_Symbol))
      return PositionGetString(POSITION_COMMENT);
   return "No Active Trade";
}

// Obtient les statistiques du jour
void GetTodayStats(int &totalTrades, int &winTrades, int &lossTrades) {
   totalTrades = 0;
   winTrades = 0;
   lossTrades = 0;

   datetime today = DateOfDay(TimeCurrent());
   int deals = HistoryDealsTotal();

   for(int i = deals - 1; i >= 0; i--) {
      ulong ticket = HistoryDealGetTicket(i);
      datetime dealTime = (datetime)HistoryDealGetInteger(ticket, DEAL_TIME);
      if(dealTime < today)
         break;

      if(HistoryDealGetString(ticket, DEAL_SYMBOL) == _Symbol) {
         double profit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
         totalTrades++;
         if(profit > 0) winTrades++;
         else if(profit < 0) lossTrades++;
      }
   }
}

// Calcule le profit du jour
double GetDailyProfit() {
   double profitToday = 0.0;
   datetime today = DateOfDay(TimeCurrent());
   int deals = HistoryDealsTotal();

   for(int i = deals - 1; i >= 0; i--) {
      ulong ticket = HistoryDealGetTicket(i);
      datetime dealTime = (datetime)(ulong)HistoryDealGetInteger(ticket, DEAL_TIME);
      if(dealTime < today)
         break;

      if(HistoryDealGetString(ticket, DEAL_SYMBOL) == _Symbol)
         profitToday += HistoryDealGetDouble(ticket, DEAL_PROFIT);
   }
   return profitToday;
}

// Calcule le taux de réussite global
double CalculateWinRate() {
   int totalTrades = 0;
   int winningTrades = 0;

   int totalHistory = HistoryDealsTotal();
   for(int i = totalHistory - 1; i >= 0; i--) {
      ulong dealTicket = HistoryDealGetTicket(i);
      if(dealTicket != 0) {
         double profit = HistoryDealGetDouble(dealTicket, DEAL_PROFIT);
         if(profit != 0.0) {
            totalTrades++;
            if(profit > 0.0)
               winningTrades++;
         }
      }
   }

   if(totalTrades == 0)
      return 0.0;

   return (double)winningTrades / totalTrades * 100.0;
}

// Charge les performances des stratégies
void LoadStrategyPerformance() {
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      string prefix = "STRAT_" + EnumToString(strategyPerformance[i].strategy) + "_";
      strategyPerformance[i].wins = (int)GlobalVariableGet(prefix + "WINS");
      strategyPerformance[i].losses = (int)GlobalVariableGet(prefix + "LOSSES");
      strategyPerformance[i].totalTrades = (int)GlobalVariableGet(prefix + "TOTAL");
      strategyPerformance[i].totalProfit = GlobalVariableGet(prefix + "PROFIT");
      strategyPerformance[i].lastTradeTime = (datetime)GlobalVariableGet(prefix + "LAST_TIME");
   }
}

// Sauvegarde les performances des stratégies
void SaveStrategyPerformance() {
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      string prefix = "STRAT_" + EnumToString(strategyPerformance[i].strategy) + "_";
      GlobalVariableSet(prefix + "WINS", strategyPerformance[i].wins);
      GlobalVariableSet(prefix + "LOSSES", strategyPerformance[i].losses);
      GlobalVariableSet(prefix + "TOTAL", strategyPerformance[i].totalTrades);
      GlobalVariableSet(prefix + "PROFIT", strategyPerformance[i].totalProfit);
      GlobalVariableSet(prefix + "LAST_TIME", (double)strategyPerformance[i].lastTradeTime);
   }
}

// Met à jour les poids des stratégies
void UpdateStrategyWeights() {
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].totalTrades < 5) continue;
      
      double recentWinRate = strategyPerformance[i].wins / (double)MathMax(20, strategyPerformance[i].totalTrades) * 100.0;
      double mediumWinRate = strategyPerformance[i].wins / (double)MathMax(100, strategyPerformance[i].totalTrades) * 100.0;
      
      double atr = iATR(_Symbol, _Period, 14);
      double volatilityFactor = (atr > 0.0005) ? 1.2 : (atr < 0.0002) ? 0.8 : 1.0;
      
      strategyPerformance[i].weight = recentWinRate * 0.5 + mediumWinRate * 0.3 + volatilityFactor * 0.2;
   }
}

// Gestion automatique des stratégies
void AutoManageStrategies() {
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      if(strategyPerformance[i].totalTrades < MinTradesToDisable) continue;
      
      strategyPerformance[i].winRate = (double)strategyPerformance[i].wins / strategyPerformance[i].totalTrades * 100.0;
      
      if(strategyPerformance[i].winRate < MinWinRateToDisable) {
         strategyPerformance[i].enabled = false;
         strategyPerformance[i].lastTradeTime = TimeCurrent();
         if(EnableNotifications) {
            Alert(_Symbol + " " + EnumToString(_Period) + ": Strategy Disabled: " + EnumToString(strategyPerformance[i].strategy) + 
                            " (Win Rate: " + DoubleToString(strategyPerformance[i].winRate, 1) + "%)");
         }
      }
      
      if(!strategyPerformance[i].enabled && 
         TimeCurrent() - strategyPerformance[i].lastTradeTime > ReEnableAfterHours * 3600) {
         strategyPerformance[i].enabled = true;
         if(EnableNotifications) {
            Alert(_Symbol + " " + EnumToString(_Period) + ": Strategy Re-enabled: " + EnumToString(strategyPerformance[i].strategy));
         }
      }
   }
}

//===================================================
// SECTION 8 : FONCTIONS DU DASHBOARD
//===================================================

// Dessine une barre de progression
void DrawProgressBar(string name, int x, int y, double percent, color clrPositive, color clrNegative) {
    int width = 150;
    int height = 15;
    
    ObjectCreate(0, name+"_BG", OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name+"_BG", OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name+"_BG", OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name+"_BG", OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name+"_BG", OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name+"_BG", OBJPROP_COLOR, clrGray);
    ObjectSetInteger(0, name+"_BG", OBJPROP_BACK, true);
    
    int progressWidth = (int)(width * percent / 100.0);
    ObjectCreate(0, name+"_FG", OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name+"_FG", OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name+"_FG", OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name+"_FG", OBJPROP_XSIZE, progressWidth);
    ObjectSetInteger(0, name+"_FG", OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name+"_FG", OBJPROP_COLOR, percent >= 50 ? clrPositive : clrNegative);
    ObjectSetInteger(0, name+"_FG", OBJPROP_BACK, false);
}

// Crée un bouton
void CreateButton(string name, string text, int x, int y, int width, int height, color bgColor) {
    ObjectCreate(0, name, OBJ_RECTANGLE_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
    ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
    ObjectSetInteger(0, name, OBJPROP_XSIZE, width);
    ObjectSetInteger(0, name, OBJPROP_YSIZE, height);
    ObjectSetInteger(0, name, OBJPROP_COLOR, bgColor);
    ObjectSetInteger(0, name, OBJPROP_BACK, false);
    
    ObjectCreate(0, name+"_TXT", OBJ_LABEL, 0, 0, 0);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_XDISTANCE, x + width/2 - StringLen(text)*3);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_YDISTANCE, y + height/2 - 8);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_COLOR, clrWhite);
    ObjectSetInteger(0, name+"_TXT", OBJPROP_FONTSIZE, 10);
    ObjectSetString(0, name+"_TXT", OBJPROP_TEXT, text);
}

// Dessine l'arrière-plan du dashboard
void DrawDashboardBackground(int x, int y, int width, int height) {
   string bgName = "DASHBOARD_BG";
   ObjectDelete(0, bgName);
   ObjectCreate(0, bgName, OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, bgName, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, bgName, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, bgName, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, bgName, OBJPROP_XSIZE, width);
   ObjectSetInteger(0, bgName, OBJPROP_YSIZE, height);
   ObjectSetInteger(0, bgName, OBJPROP_COLOR, C'10,20,40');
   ObjectSetInteger(0, bgName, OBJPROP_BACK, true);
   ObjectSetInteger(0, bgName, OBJPROP_SELECTABLE, false);
}

// Met à jour le dashboard
void UpdateDashboard() {
   DeleteDashboard();

   int x = DashboardPosX;
   int y = DashboardPosY;

   // Crée le panneau principal
   ObjectCreate(0, "DASHBOARD_PANEL", OBJ_RECTANGLE_LABEL, 0, 0, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_XSIZE, DashboardWidth);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_YSIZE, DashboardHeight + 150);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_CORNER, 0);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_COLOR, C'30,30,30');
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_BACK, true);
   ObjectSetInteger(0, "DASHBOARD_PANEL", OBJPROP_SELECTABLE, false);

   y += 15;
   int fontSize = 12;

   // Affiche les informations de base
   string header = "PAIR: " + _Symbol + " | TF: " + EnumToString(_Period);
   DisplayLabel("DASHBOARD_PAIR_TF", header, x + 15, y, clrGold, fontSize);
   y += 20;

   string strategy = "STRATEGY: " + LastStrategyUsed();
   DisplayLabel("DASHBOARD_STRATEGY", strategy, x + 15, y, clrWhite, fontSize);
   y += 20;

   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   DisplayLabel("DASHBOARD_BALANCE", "BALANCE: " + DoubleToString(balance, 2), x + 15, y, clrWhite, fontSize);
   y += 20;
   DisplayLabel("DASHBOARD_EQUITY", "EQUITY: " + DoubleToString(equity, 2), x + 15, y, clrWhite, fontSize);
   y += 20;

   // Affiche le profit du jour
   double profitToday = GetDailyProfit();
   color profitColor = profitToday >= 0 ? clrLime : clrOrange;
   DisplayLabel("DASHBOARD_PROFIT_DAY", "DAILY PROFIT: " + FormatSigned(profitToday, 2), x + 15, y, profitColor, fontSize, true);
   y += 20;

   // Affiche le spread actuel
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   DisplayLabel("DASHBOARD_SPREAD", "CURRENT SPREAD: " + DoubleToString(spread, Digits()), x + 15, y, clrWhite, fontSize);
   y += 20;

   y += 10;
   DisplayLabel("DASHBOARD_SEPARATOR", "----------- DAILY STATISTICS -----------", x + 15, y, clrAqua, fontSize);
   y += 20;

   // Statistiques quotidiennes
   int totalTradesToday, winTradesToday, lossTradesToday;
   GetTodayStats(totalTradesToday, winTradesToday, lossTradesToday);

   DisplayLabel("DASHBOARD_TODAY_TRADES", "TOTAL TRADES TODAY: " + IntegerToString(totalTradesToday), x + 15, y, clrWhite, fontSize);
   y += 20;

   DisplayLabel("DASHBOARD_TODAY_WINS", "WINS: " + IntegerToString(winTradesToday) + " | LOSSES: " + IntegerToString(lossTradesToday), x + 15, y, clrWhite, fontSize);
   y += 20;

   double plToday = GetDailyProfit();
   double winRateToday = totalTradesToday > 0 ? 100.0 * winTradesToday / totalTradesToday : 0.0;
   DisplayLabel("DASHBOARD_TODAY_PL", "P/L TODAY: " + FormatSigned(plToday, 2), x + 15, y, plToday >= 0 ? clrLime : clrOrange, fontSize, true);
   y += 20;

   // Barre de progression pour le taux de réussite
   DrawProgressBar("WINRATE_BAR", x + 15, y, winRateToday, clrGreen, clrRed);
   DisplayLabel("DASHBOARD_WINRATE", "WIN RATE TODAY: " + DoubleToString(winRateToday, 1) + "%", x + 220, y, clrYellow, fontSize);
   y += 30;

   // Statut de l'EA
   string status = ea_is_active ? "ACTIVE" : "PAUSED";
   color statusColor = ea_is_active ? clrLime : clrRed;
   DisplayLabel("DASHBOARD_STATUS", "STATUS: " + status, x + 15, y, statusColor, 14, true);
   y += 30;
}

// Supprime le dashboard
void DeleteDashboard() {
   ObjectDelete(0, "DASHBOARD_PANEL");

   string elements[] = {
      "DASHBOARD_PAIR_TF",
      "DASHBOARD_STRATEGY",
      "DASHBOARD_BALANCE",
      "DASHBOARD_EQUITY",
      "DASHBOARD_PROFIT_DAY",
      "DASHBOARD_SPREAD",
      "DASHBOARD_SEPARATOR",
      "DASHBOARD_TODAY_TRADES",
      "DASHBOARD_TODAY_WINS",
      "DASHBOARD_TODAY_PL",
      "WINRATE_BAR_BG",
      "WINRATE_BAR_FG",
      "DASHBOARD_WINRATE",
      "DASHBOARD_STATUS",
      "DASHBOARD_TOGGLE",
      "DASHBOARD_TOGGLE_TXT",
      "DASHBOARD_CLOSE",
      "DASHBOARD_CLOSE_TXT"
   };

   for(int i = 0; i < ArraySize(elements); i++)
      ObjectDelete(0, elements[i]);
}

// Affiche un label
void DisplayLabel(string name, string text, int x, int y, color txtColor, int size, bool bold=false) {
   ObjectCreate(0, name, OBJ_LABEL, 0, 0, 0);
   ObjectSetInteger(0, name, OBJPROP_XDISTANCE, x);
   ObjectSetInteger(0, name, OBJPROP_YDISTANCE, y);
   ObjectSetInteger(0, name, OBJPROP_COLOR, txtColor);
   ObjectSetInteger(0, name, OBJPROP_FONTSIZE, size);
   ObjectSetInteger(0, name, OBJPROP_CORNER, 0);
   ObjectSetInteger(0, name, OBJPROP_SELECTABLE, false);
   ObjectSetString(0, name, OBJPROP_TEXT, text);
}

//===================================================
// SECTION 9 : FONCTIONS PRINCIPALES DE L'EA
//===================================================

//+------------------------------------------------------------------+
//| Fonction d'initialisation                                       |
//+------------------------------------------------------------------+
int OnInit() {
   // Vérification des symboles autorisés
   string allowedSymbols[] = {"EURUSD", "USDJPYm", "EURGBP", "XAUUSDm", "GOLD", "BTCUSD"};
   bool symbolAllowed = false;
   for(int i=0; i<ArraySize(allowedSymbols); i++) {
      if(_Symbol == allowedSymbols[i]) {
         symbolAllowed = true;
         break;
      }
   }
   
   if(!symbolAllowed) {
      Alert("EA DIAMOND v26 ne peut pas trader ce symbole ", _Symbol);
      return INIT_FAILED;
   }

   // Initialisation des variables globales
   g_LastEquity  = AccountInfoDouble(ACCOUNT_EQUITY);
   g_LastBalance = AccountInfoDouble(ACCOUNT_BALANCE);
   g_ATRValue    = 0.0;
   g_IsGold      = (StringFind(_Symbol, "GOLD") >= 0 || StringFind(_Symbol, "XAUUSDm") >= 0);

   // Initialisation des performances des stratégies
   for(int i = 0; i < STRATEGY_COUNT; i++) {
      strategyPerformance[i].strategy = (ENUM_STRATEGY)(i+1);
      strategyPerformance[i].enabled = true;
      strategyPerformance[i].weight = 1.0;
   }
   
    EnableSuperTrend = EnableSuperTrendInput;

   // Initialisation des indicateurs avec gestion d'erreur améliorée
   if(!strategyManager.InitializeIndicators()) {
      Print("Échec d'initialisation des indicateurs - continuation avec stratégies disponibles");
      
      // Désactive automatiquement les stratégies problématiques
      for(int i = 0; i < STRATEGY_COUNT; i++) {
         if(strategyPerformance[i].strategy == STRAT_SUPERTREND) {
            strategyPerformance[i].enabled = false;
            Print("Stratégie SuperTrend désactivée automatiquement");
         }
      }
   }
   
   if(!strategyManager.CheckIndicators()) {
      Print("Vérification des indicateurs échouée");
   }

   // Initialisation des stratégies
   strategies_total = 0;
   ArrayResize(strategies, STRATEGY_COUNT);

   for(int i = 0; i < STRATEGY_COUNT; i++) {
      StrategyStats s;
      s.Enabled = true;
      s.TotalTrades = 0;
      s.Wins = 0;
      s.Losses = 0;
      s.Profit = 0.0;
      s.WinRate = 0.0;
      s.StatusColor = clrSilver;

      switch(i + 1) {
         case STRAT_CHECKLIST:
            s.Name = "Checklist";
            s.StatusColor = clrLime;
            break;
         case STRAT_BREAKOUT_RANGE:
            s.Name = "Breakout";
            s.StatusColor = clrGold;
            break;
         case STRAT_PULLBACK_EMA:
            s.Name = "Pullback EMA";
            s.StatusColor = clrOrange;
            break;
         case STRAT_SUPERTREND:
            s.Name = "SuperTrend";
            s.StatusColor = clrDeepSkyBlue;
            break;
         case STRAT_RETEST_SR:
            s.Name = "Retest SR";
            s.StatusColor = clrDodgerBlue;
            break;
         case STRAT_SCALPING:
            s.Name = "Scalping";
            s.StatusColor = clrViolet;
            break;
      }

      strategies[strategies_total++] = s;
   }

   LoadStrategyPerformance();
   EventSetTimer(10);
   
   return INIT_SUCCEEDED;
}

//+------------------------------------------------------------------+
//| Fonction de désinitialisation                                   |
//+------------------------------------------------------------------+
void OnDeinit(const int reason) {
   SaveStrategyPerformance();
   DeleteDashboard();
   ObjectsDeleteAll(0, "Dashboard_");
   EventKillTimer();
}

//+------------------------------------------------------------------+
//| Fonction exécutée à chaque tick                                 |
//+------------------------------------------------------------------+
// === OnTick principal de l'EA DIAMOND ===
void OnTick() {
    //=== 1. INITIALISATION ET JOURNALISATION ===//
    static int tickCount = 0; // Compteur de ticks pour logs périodiques
    tickCount++;

    // Logs détaillés (tous les 100 ticks si debug actif)
    if(EnableDebugLog && tickCount % 100 == 0) {
        Print("=== STATUT EA ===");
        Print("Heure: ", TimeCurrent());
        Print("Symbol: ", _Symbol);
        Print("Timeframe: ", EnumToString(_Period));
        Print("EA active: ", ea_is_active);
        Print("Stratégies actives:");
        for(int i = 0; i < STRATEGY_COUNT; i++) {
            if(strategyPerformance[i].enabled)
                Print("- ", EnumToString(strategyPerformance[i].strategy));
        }
    }

    //=== 2. VÉRIFICATION DE L'ÉTAT DE L'EA ===//
    if(!ea_is_active) {
        Print("DEBUG OnTick: EA désactivé.");
        return;
    }

    //=== 3. CONTRÔLE DU SPREAD ===//
    double spread_pips = strategyManager.GetSpreadPips();
    double max_spread_pips = strategyManager.GetDynamicSpreadThreshold();
    if(spread_pips > max_spread_pips) {
        Comment("Spread trop élevé : ", DoubleToString(spread_pips,1), 
                " pips (Max autorisé : ", DoubleToString(max_spread_pips,1), ")");
        if(EnableDebugLog) {
            PrintFormat("[SPREAD] Blocage %s - Spread actuel: %.1f pips > Seuil: %.1f pips",
                        _Symbol, spread_pips, max_spread_pips);
        }
        return;
    }

    //=== 4. MISE À JOUR DU DASHBOARD ===//
    static datetime lastDashboardUpdate = 0;
    if(TimeCurrent() - lastDashboardUpdate >= 1) {
        UpdateDashboard();
        lastDashboardUpdate = TimeCurrent();
    }

    //=== 5. VÉRIFICATION DES DONNÉES DISPONIBLES ===//
    if(Bars(_Symbol, _Period) < MIN_BARS_REQUIRED) {
        Print("OnTick - Données insuffisantes pour ", _Symbol, 
              " (", Bars(_Symbol, _Period), " barres)");
        return;
    }

    //=== 6. VÉRIFICATION PÉRIODIQUE DES INDICATEURS ===//
    static datetime lastIndicatorCheck = 0;
    if(TimeCurrent() - lastIndicatorCheck >= 30) {
        if(!strategyManager.AreIndicatorsReady()) {
            Print("Réinitialisation des indicateurs...");
            if(!strategyManager.InitializeIndicators()) {
                Alert("Échec critique de l'initialisation des indicateurs!");
            }
        }
        lastIndicatorCheck = TimeCurrent();
    }

    //=== 7. MISE À JOUR DE L'ATR GLOBAL ===//
    double atrValue = iATR(_Symbol, _Period, ATRPeriod);
    if(atrValue > 0 && atrValue != EMPTY_VALUE) {
        g_ATRValue = atrValue;
    } else if(EnableDebugLog) {
        Print("[ATR] Valeur anormale détectée : ", atrValue);
    }

    //=== 8. GESTION INTELLIGENTE DES SORTIES ===//
    CheckIntelligentExit();

    //=== 9. GESTION DES POSITIONS EXISTANTES ===//
    if(!tradeManager.CanOpenNewPosition(_Symbol)) {
        Print("DEBUG OnTick: CanOpenNewPosition=false, pas de nouveau trade possible");
        tradeManager.ManagePositions();
        return;
    }

    //=== 10. GÉNÉRATION ET EXÉCUTION DES SIGNAUX ===//
    Print("DEBUG BLOC SIGNAL : On va appeler CheckTradingConditions");
    STradeSignal signal;
    signal.valid = false;
    bool ok = CheckTradingConditions(signal);
    Print("DEBUG OnTick: CheckTradingConditions=", ok, 
          " signal.valid=", signal.valid, 
          " isBuySignal=", signal.isBuySignal, 
          " price=", signal.price);

    if(ok && signal.valid) {
        double lots = riskManager.CalculatePositionSize(signal.price, signal.sl);
        Print("DEBUG OnTick: lots calculés = ", lots, " SL=", signal.sl, " TP=", signal.tp);
        Print("DEBUG RiskManager.IsTradeAllowed() = ", riskManager.IsTradeAllowed());

        if(lots > 0 && riskManager.IsTradeAllowed()) {
            bool result = false;
            if(signal.isBuySignal) {
                Print("DEBUG OnTick: Tentative d'achat BUY lots=", lots, " price=", signal.price, " SL=", signal.sl, " TP=", signal.tp);
                result = trade.Buy(lots, _Symbol, signal.price, signal.sl, signal.tp, signal.comment);
            } else {
                Print("DEBUG OnTick: Tentative de vente SELL lots=", lots, " price=", signal.price, " SL=", signal.sl, " TP=", signal.tp);
                result = trade.Sell(lots, _Symbol, signal.price, signal.sl, signal.tp, signal.comment);
            }

            int err = GetLastError();
            if(result) {
                Print("Trade ouvert avec succès : ", signal.comment, " lots=", lots, " SL=", signal.sl, " TP=", signal.tp);
            } else {
                PrintFormat("Échec de l'ouverture du trade! Erreur %d: %s", err, ErrorDescription(err));
            }
        } else {
            Print("Trade bloqué par lot=0 ou RiskManager (IsTradeAllowed=false). lots=", lots, " RiskManager=", riskManager.IsTradeAllowed());
        }
    } else {
        Print("DEBUG OnTick: Pas de trade, conditions non réunies (ok=", ok, " valid=", signal.valid, ")");
    }

    //=== 11. GESTION DES STOPS (TOUS LES TICKS) ===//
    tradeManager.ManagePositions();
}

// === Fonction helper pour les descriptions d'erreur ===
string ErrorDescription(int errorCode) {
    switch(errorCode) {
        case 4753: return "ERREUR 4753 : Stops invalides";
        case 4756: return "ERREUR 4756 : Volume invalide";
        case 10030: return "ERREUR 10030 : Pas assez de marge";
        case 10013: return "ERREUR 10013 : Marché fermé";
        case 10004: return "ERREUR 10004 : Ordre rejeté";
        default: return "Erreur inconnue";
    }
}
//+------------------------------------------------------------------+
//| Fonction timer                                                  |
//+------------------------------------------------------------------+
void OnTimer() {
   if(EnableStrategyAutoManagement) {
      AutoManageStrategies();
   }
   
   UpdateStrategyWeights();
   UpdateDashboard();
}

//+------------------------------------------------------------------+
//| Gestion des événements du chart                                 |
//+------------------------------------------------------------------+
void OnChartEvent(const int id,
                  const long &lparam,
                  const double &dparam,
                  const string &sparam) {
   if(id == CHARTEVENT_OBJECT_CLICK) {
      string obj_name = sparam;
      if(obj_name == "DASHBOARD_CLOSE") {
         ea_is_active = false;
         Comment("EA Désactivé");
      }
   }
}

//===================================================
// SECTION 10 : FONCTIONS SUPPLEMENTAIRES
//===================================================

//+------------------------------------------------------------------+
//| Vérifie les conditions de trading                                |
//+------------------------------------------------------------------+
bool CheckTradingConditions(STradeSignal &signal)
{
    Print("DEBUG: Entrée dans CheckTradingConditions");

    // Vérification RiskManager
    if(!riskManager.IsTradeAllowed())
    {
        Print("DEBUG: RiskManager refuse le trade");
        signal.valid = false;
        Print("DEBUG: Avant return false (IsTradeAllowed)");
        return false;
    }

    // Vérification de la disponibilité des indicateurs
    if(!strategyManager.AreIndicatorsReady())
    {
        Print("DEBUG: Les indicateurs ne sont pas prêts");
        signal.valid = false;
        Print("DEBUG: Avant return false (AreIndicatorsReady)");
        return false;
    }

    bool signalFound = false;

    // Boucle sur toutes les stratégies activées
    for(int i = 0; i < STRATEGY_COUNT; i++)
    {
        if(!strategyPerformance[i].enabled) continue;

        Print("DEBUG: Avant stratégie ", EnumToString(strategyPerformance[i].strategy), " i=", i);

        switch(strategyPerformance[i].strategy)
        {
            case STRAT_CHECKLIST:
                Print("DEBUG: Appel ChecklistStrategySignal");
                signalFound = strategyManager.ChecklistStrategySignal(signal);
                Print("DEBUG: Retour ChecklistStrategySignal : signalFound=", signalFound, " valid=", signal.valid);
                break;
            case STRAT_SUPERTREND:
                Print("DEBUG: Appel DetectSuperTrendSignal");
                signalFound = strategyManager.DetectSuperTrendSignal(signal);
                Print("DEBUG: Retour DetectSuperTrendSignal : signalFound=", signalFound, " valid=", signal.valid);
                break;
            case STRAT_RETEST_SR:
                Print("DEBUG: Appel DetectSRRetestSignal");
                signalFound = strategyManager.DetectSRRetestSignal(signal);
                Print("DEBUG: Retour DetectSRRetestSignal : signalFound=", signalFound, " valid=", signal.valid);
                break;
            case STRAT_BREAKOUT_RANGE:
                Print("DEBUG: Appel DetectBreakoutSignal");
                signalFound = strategyManager.DetectBreakoutSignal(signal);
                Print("DEBUG: Retour DetectBreakoutSignal : signalFound=", signalFound, " valid=", signal.valid);
                break;
            case STRAT_PULLBACK_EMA:
                Print("DEBUG: Appel DetectPullbackEMASignal");
                signalFound = strategyManager.DetectPullbackEMASignal(signal);
                Print("DEBUG: Retour DetectPullbackEMASignal : signalFound=", signalFound, " valid=", signal.valid);
                break;
            case STRAT_SCALPING:
                Print("DEBUG: Appel DetectScalpingSignal");
                signalFound = strategyManager.DetectScalpingSignal(signal);
                Print("DEBUG: Retour DetectScalpingSignal : signalFound=", signalFound, " valid=", signal.valid);
                break;
            default:
                Print("DEBUG: Stratégie inconnue : ", strategyPerformance[i].strategy);
                break;
        }

        Print("DEBUG: Après stratégie ", EnumToString(strategyPerformance[i].strategy), " i=", i, " signalFound=", signalFound, " valid=", signal.valid);

        if(signalFound && signal.valid) {
            Print("DEBUG: Signal trouvé et validé, on sort de la boucle");
            break;
        }
    }

    Print("DEBUG: Avant return dans CheckTradingConditions, signalFound=", signalFound, " valid=", signal.valid, " isBuySignal=", signal.isBuySignal);
    return signalFound;
}

//+------------------------------------------------------------------+
//| Ouvre un trade basé sur le signal                                |
//+------------------------------------------------------------------+
bool OpenTrade(const STradeSignal &signal)
{
   return tradeManager.ExecuteTrade(signal);
}

//+------------------------------------------------------------------+
//| Ferme toutes les positions ouvertes                              |
//+------------------------------------------------------------------+
void PerformFullClose()
{
   int total = PositionsTotal();
   for(int i = total-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic = (int)PositionGetInteger(POSITION_MAGIC);
         if(pos_symbol == _Symbol && pos_magic == MagicNumber)
         {
            trade.PositionClose(ticket);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Vérifie les conditions pour une sortie intelligente              |
//+------------------------------------------------------------------+
void CheckIntelligentExit()
{
   double totalProfit = 0.0;
   int openPositions = 0;
   
   for(int i = PositionsTotal()-1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         string pos_symbol = PositionGetString(POSITION_SYMBOL);
         int pos_magic = (int)PositionGetInteger(POSITION_MAGIC);
         if(pos_symbol == _Symbol && pos_magic == MagicNumber)
         {
            totalProfit += PositionGetDouble(POSITION_PROFIT);
            openPositions++;
         }
      }
   }
   
   if(openPositions > 0)
   {
      double balance = AccountInfoDouble(ACCOUNT_BALANCE);
      double equity = AccountInfoDouble(ACCOUNT_EQUITY);
      double drawdown = (balance - equity) / balance * 100.0;
      
      // Conditions de sortie
      if(drawdown >= MaxDailyLossPercent || 
         DetectMarketAnomaly() || 
         totalProfit >= balance * 0.05) // 5% de profit total
      {
         PerformFullClose();
         Print("Fermeture intelligente déclenchée. Raison: ",
               drawdown >= MaxDailyLossPercent ? "Drawdown excessif" :
               DetectMarketAnomaly() ? "Anomalie marché" : "Objectif profit atteint");
      }
   }
}

//+------------------------------------------------------------------+
//| Détecte les anomalies du marché                                 |
//+------------------------------------------------------------------+
bool DetectMarketAnomaly()
{
   // Vérification du spread
   double spread = SymbolInfoInteger(_Symbol, SYMBOL_SPREAD) * _Point;
   double maxSpread = strategyManager.GetDynamicSpreadThreshold();

   
   // Vérification de la volatilité
   double atr = iATR(_Symbol, _Period, 14);
   double normalATR = 0.0;
   
   // Calcul de l'ATR moyen sur 100 périodes
   for(int i = 1; i <= 100; i++)
   {
      normalATR += iATR(_Symbol, _Period, ATRPeriod);
   }
   normalATR /= 100;
   
   // Conditions d'anomalie
   if(spread > maxSpread * 1.5)
   {
      Print("Anomalie marché: Spread anormalement élevé (", spread, ")");
      return true;
   }
   
   if(atr > normalATR * 3.0)
   {
      Print("Anomalie marché: Volatilité anormale (ATR actuel: ", atr, ", ATR moyen: ", normalATR, ")");
      return true;
   }
   
   return false;
}

//===================================================
// SECTION 11 : OPTIMISATION ET UTILITAIRES AVANCÉS
//===================================================

//+------------------------------------------------------------------+
//| Calcule la performance des stratégies                            |
//+------------------------------------------------------------------+
void CalculateStrategyPerformance()
{
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(PositionSelectByTicket(ticket))
      {
         string comment = PositionGetString(POSITION_COMMENT);
         double profit = PositionGetDouble(POSITION_PROFIT);
         
         for(int j = 0; j < STRATEGY_COUNT; j++)
         {
            if(StringFind(comment, EnumToString(strategyPerformance[j].strategy)) >= 0)
            {
               strategyPerformance[j].totalTrades++;
               if(profit > 0) strategyPerformance[j].wins++;
               else strategyPerformance[j].losses++;
               strategyPerformance[j].totalProfit += profit;
               break;
            }
         }
      }
   }
   
   // Mise à jour des statistiques
   for(int j = 0; j < STRATEGY_COUNT; j++)
   {
      if(strategyPerformance[j].totalTrades > 0)
      {
         strategyPerformance[j].winRate = (double)strategyPerformance[j].wins / 
                                        strategyPerformance[j].totalTrades * 100.0;
         strategyPerformance[j].profitFactor = (strategyPerformance[j].losses == 0) ? 
                                             DBL_MAX : 
                                             strategyPerformance[j].wins / (double)strategyPerformance[j].losses;
      }
   }
}

//+------------------------------------------------------------------+
//| Optimise dynamiquement les paramètres                            |
//+------------------------------------------------------------------+
void DynamicOptimization()
{
   // Utilisez la variable globale, ne la redéclarez pas ici !
   // static datetime lastOptimization = 0; // Retirer cette ligne si vous avez déjà "datetime lastOptimization" en global

   if(TimeCurrent() - lastOptimization < 86400) 
      return; // Une fois par jour

   // Optimisation basée sur la performance récente
   for(int i = 0; i < STRATEGY_COUNT; i++)
   {
      if(strategyPerformance[i].totalTrades < 20) 
         continue;
      
      // Désactivation des stratégies sous-performantes
      if(strategyPerformance[i].winRate < MinWinRateToDisable)
      {
         strategyPerformance[i].enabled = false;
         Print("Stratégie désactivée: ", EnumToString(strategyPerformance[i].strategy),
               " (WinRate: ", DoubleToString(strategyPerformance[i].winRate, 1), "%)");
      }
      
      // Ajustement dynamique des paramètres pour SuperTrend
      if(strategyPerformance[i].strategy == STRAT_SUPERTREND && 
         strategyPerformance[i].profitFactor < 1.5)
      {
         double newMultiplier = SuperTrend_Multiplier * 0.9;
         // On ne peut PAS modifier un input (SuperTrend_Multiplier), on ne fait qu'informer ici
         Print("Ajustement (simulation) SuperTrend Multiplier à: ", DoubleToString(MathMax(newMultiplier, 2.0)));
      }
   }

   // Met à jour la date de dernière optimisation
   lastOptimization = TimeCurrent();
}
//+------------------------------------------------------------------+
//| Gestion avancée du money management                              |
//+------------------------------------------------------------------+
//+------------------------------------------------------------------+ 
void AdvancedMoneyManagement()
{
   double balance = AccountInfoDouble(ACCOUNT_BALANCE);
   double equity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   // Ajustement dynamique du risque
   if(equity > balance)
   {
      // Correction : parenthèses fermantes ajoutées
      Print("Suggesté nouveau RiskPercent: ", DoubleToString(MathMin(RiskPercent * 1.1, 2.0)));
   }
   else
   {
      Print("Suggesté nouveau RiskPercent: ", DoubleToString(MathMax(RiskPercent * 0.9, 0.5)));
   }
   // RiskPercent = MathMax(RiskPercent * 0.9, 0.5); // Ne pas modifier un input ici

   // Journalisation
   if(EnableDebugLog)
   {
      Print("Money Management - Risk ajusté à: ", DoubleToString(RiskPercent, 1), "%",
            " (Balance: ", DoubleToString(balance, 2), 
            ", Equity: ", DoubleToString(equity, 2), ")");
   }
}
//+------------------------------------------------------------------+
//| Fonction de journalisation avancée                               |
//+------------------------------------------------------------------+
void AdvancedLogging()
{
   if(!EnableDebugLog) return;
   
   static datetime lastLog = 0;
   if(TimeCurrent() - lastLog < 3600) return; // Toutes les heures
   
   string logText = "=== JOURNAL DÉTAILLÉ ===\n";
   logText += "Heure: " + TimeToString(TimeCurrent()) + "\n";
   logText += "Symbol: " + _Symbol + "\n";
   logText += "Balance: " + DoubleToString(AccountInfoDouble(ACCOUNT_BALANCE), 2) + "\n";
   logText += "Equity: " + DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2) + "\n";
   logText += "Performance des stratégies:\n";
   
   for(int i = 0; i < STRATEGY_COUNT; i++)
   {
      logText += StringFormat("- %s: %d trades, %.1f%% WR, PF: %.2f\n",
                            EnumToString(strategyPerformance[i].strategy),
                            strategyPerformance[i].totalTrades,
                            strategyPerformance[i].winRate,
                            strategyPerformance[i].profitFactor);
   }
   
   // Écriture dans un fichier
   int handle = FileOpen("DiamondEA_Log.txt", FILE_WRITE|FILE_TXT);
   if(handle != INVALID_HANDLE)
   {
      FileWrite(handle, logText);
      FileClose(handle);
   }
   
   lastLog = TimeCurrent();
}



//+------------------------------------------------------------------+
//| FIN DU CODE - DIAMOND EA VER26 - CORRECTED                      |
//+------------------------------------------------------------------+